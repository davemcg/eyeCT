[{"path":"https://davemcg.github.io/metamoRph/articles/So_many_ways_to_screw_up_PCA_projection.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"So many ways to screw up PCA projection","text":"run prcomp get two matrices back: $x $rotation. former “pattern matrix” factors (principal components) samples. latter amplitude matrix, loadings features (genes) factors (principal compoent); row column, respectively. theory can use rotation (loadings) matrix prcomp ($rotation slot) multiply new matrix get new matrix eigenvector space original matrix. handy! means can use existing PCA understand spent time interpreting transfer knowledge onto new data. practice, though, wide variety reasons can fail. Let us explore .","code":""},{"path":"https://davemcg.github.io/metamoRph/articles/So_many_ways_to_screw_up_PCA_projection.html","id":"toy-data","dir":"Articles","previous_headings":"","what":"Toy Data","title":"So many ways to screw up PCA projection","text":"Let’s make tiny little faux dataset. Threetissue types five genes. log1p scale data raw gene counts skewed, run prcomp, plot first two principal components (PC). nice job turning three major axes variation two informative eigenvalues/PCs.","code":"library(dplyr) library(ggplot2)  genes <- c('RHO','RPE65','ABCA4','PMEL', 'KRT5') samples <- c('Retina1','Retina2','RPE1','RPE2','Cornea1')  faux_mat <- cbind(c(560,650,5,6,9), # rho                   c(42,32, 1103,1201,2), #rpe65                   c(810,903,202,205,45),  #abca4                   c(100,105,2004,1980,101),# pmel                   c(3,32,101,202,1867)) |> data.frame()# krt5 colnames(faux_mat) <- genes row.names(faux_mat) <- samples  faux_pca <- prcomp(log1p(faux_mat), scale = TRUE, center = TRUE)  faux_pca$x |>   as_tibble(rownames = 'samples') |>   mutate(samples = gsub('\\\\d','',samples)) |>   ggplot(aes(x=PC1,y=PC2,color=samples)) +    geom_point() +   cowplot::theme_cowplot()"},{"path":"https://davemcg.github.io/metamoRph/articles/So_many_ways_to_screw_up_PCA_projection.html","id":"matrix-multiplication","dir":"Articles","previous_headings":"Toy Data","what":"Matrix Multiplication","title":"So many ways to screw up PCA projection","text":"pattern matrix (plotted ) can recreated multiplying input_matrix rotation matrix ($rotation slot). Wait, ’s wrong….numbers different. PC1 range -2 2, now runs -5 3. happened? investigate prcomp documentation see input data, default, scaled across features. apply scale function log1p scaled faux_mat get matrix exactly matches prcomp $x slot.","code":"as.matrix(log1p(faux_mat)) %*% faux_pca$rotation #>               PC1      PC2       PC3         PC4      PC5 #> Retina1 -3.665190 6.706788 -7.344774 -0.19334184 3.146782 #> Retina2 -2.829324 5.805728 -9.090433 -0.17940189 3.181682 #> RPE1     3.019202 8.865143 -8.318996 -0.03906449 1.680128 #> RPE2     3.263775 8.661185 -8.930563 -0.21079129 1.690195 #> Cornea1  2.472395 1.693552 -9.136326  1.37485738 2.225891 scale(log1p(faux_mat)) %*% faux_pca$rotation #>               PC1        PC2         PC3           PC4           PC5 #> Retina1 -2.057963  0.2320273  0.36944476 -0.0116954785  8.204038e-16 #> Retina2 -1.701178 -0.1366033 -0.42140684  0.0118873413  4.905776e-16 #> RPE1     1.254511  1.1468746  0.12984655  0.0347133588 -6.470796e-17 #> RPE2     1.360317  1.0552042 -0.14052654 -0.0345002389 -4.941149e-17 #> Cornea1  1.144313 -2.2975028  0.06264207 -0.0004049826 -4.716018e-17  (scale(log1p(faux_mat)) %*% faux_pca$rotation) == faux_pca$x #>          PC1  PC2  PC3  PC4  PC5 #> Retina1 TRUE TRUE TRUE TRUE TRUE #> Retina2 TRUE TRUE TRUE TRUE TRUE #> RPE1    TRUE TRUE TRUE TRUE TRUE #> RPE2    TRUE TRUE TRUE TRUE TRUE #> Cornea1 TRUE TRUE TRUE TRUE TRUE"},{"path":"https://davemcg.github.io/metamoRph/articles/So_many_ways_to_screw_up_PCA_projection.html","id":"three-fake-cornea-tissues","dir":"Articles","previous_headings":"Toy Data","what":"Three fake cornea tissues","title":"So many ways to screw up PCA projection","text":"Now new data. Three cornea samples. want compare new cornea samples existing PCA see compare. discussed , able just matrix multiply new matrix original pca $loading slot put new data PC space.","code":"new_data <- cbind(c(5,6,3), # rho                   c(7,2,6), #rpe65                   c(65,22,10),  #abca4                   c(122,101,57),# pmel                   c(2567,1755,2218)) # krt5 colnames(new_data) <- genes row.names(new_data) <- c(\"Cornea2\",\"Cornea3\",\"Cornea4\")"},{"path":"https://davemcg.github.io/metamoRph/articles/So_many_ways_to_screw_up_PCA_projection.html","id":"ok-lets-try-projecting-some-new-data","dir":"Articles","previous_headings":"","what":"OK, let’s try projecting some new data!","title":"So many ways to screw up PCA projection","text":"apply knowledge scale new data matrix multiply rotation matrix. ? three new samples … middle??? ??????","code":"new_project <- scale(log1p(new_data)) %*% faux_pca$rotation  # we bind rows to glue together the original PCA (faux_pca$x) # with the new data's PC space (new_project) bind_rows(as_tibble(faux_pca$x, rownames = 'samples'),       as_tibble(new_project, rownames = 'samples')) |>   mutate(samples = gsub('\\\\d','',samples)) |>   ggplot(aes(x=PC1,y=PC2,color=samples)) +    geom_point() +   cowplot::theme_cowplot()"},{"path":"https://davemcg.github.io/metamoRph/articles/So_many_ways_to_screw_up_PCA_projection.html","id":"what-scale-does","dir":"Articles","previous_headings":"","what":"What scale does","title":"So many ways to screw up PCA projection","text":"scale takes columns , default, center (mean 0) scale (divide standard deviation). issue one sample type fairly similar expression patterns across genes, scaling turns everything similar values. centers around 0, effect multiplying prcomp rotation matrix.","code":"scale(new_data) #>                RHO      RPE65      ABCA4       PMEL       KRT5 #> Cornea2  0.2182179  0.7559289  1.1295751  0.8642016  0.9500860 #> Cornea3  0.8728716 -1.1338934 -0.3573146  0.2311237 -1.0433761 #> Cornea4 -1.0910895  0.3779645 -0.7722605 -1.0953253  0.0932901 #> attr(,\"scaled:center\") #>         RHO       RPE65       ABCA4        PMEL        KRT5  #>    4.666667    5.000000   32.333333   93.333333 2180.000000  #> attr(,\"scaled:scale\") #>        RHO      RPE65      ABCA4       PMEL       KRT5  #>   1.527525   2.645751  28.919428  33.171273 407.331560"},{"path":[]},{"path":"https://davemcg.github.io/metamoRph/articles/So_many_ways_to_screw_up_PCA_projection.html","id":"with-statspredict","dir":"Articles","previous_headings":"How to fix?","what":"with stats::predict","title":"So many ways to screw up PCA projection","text":"use stats::predict tool, use scaling information prcomp object scale new data scale center values used prcomp scale/center steps.","code":"with_predict <- predict(faux_pca, (log1p(new_data)))  bind_rows(as_tibble(faux_pca$x, rownames = 'samples'),       as_tibble(with_predict, rownames = 'samples')) |>   mutate(samples = gsub('\\\\d','',samples)) |>   ggplot(aes(x=PC1,y=PC2,color=samples)) +    geom_point() +   cowplot::theme_cowplot()"},{"path":[]},{"path":"https://davemcg.github.io/metamoRph/articles/So_many_ways_to_screw_up_PCA_projection.html","id":"plot-twist","dir":"Articles","previous_headings":"Yay all is well in the world!","what":"plot twist","title":"So many ways to screw up PCA projection","text":"RNA-seq data common wildly different sum counts. sequencing machine can create 10,000,000 reads one sample 100,000,000 reads. even ! Let’s try stats::prcomp new_data, just scaled 20x. Ugh, now new cornea samples look like RPE.","code":"with_predict <- predict(faux_pca, (log1p(new_data*20)))  bind_rows(as_tibble(faux_pca$x, rownames = 'samples'),       as_tibble(with_predict, rownames = 'samples')) |>   mutate(samples = gsub('\\\\d','',samples)) |>   ggplot(aes(x=PC1,y=PC2,color=samples)) +    geom_point() +   cowplot::theme_cowplot()"},{"path":"https://davemcg.github.io/metamoRph/articles/So_many_ways_to_screw_up_PCA_projection.html","id":"ok-so-this-is-fixable-","dir":"Articles","previous_headings":"Yay all is well in the world!","what":"OK, so this is fixable….","title":"So many ways to screw up PCA projection","text":"can either re-original PCA fixed sample scale (like cpm) /alter new data similar scale input data PCA. recap, point discussed several issues can make data projection challenging: log scaling input data log scaling new data row scaling (feature/genes) within prcomp needs applied way new data unequal sum counts samples need normalized either first prcomp step adjusting new data even little annoyances discussed: highly variable gene selection usually done don’t PCA 20,000+ genes. means new data needs exactly matched feature/gene level whatever highly variable genes used prcomp step using new RNA seq dataset different quantification setup original data gene names can slightly different, means may handful missing features/genes addressed way otherwise matrix multiplication fail…","code":""},{"path":[]},{"path":"https://davemcg.github.io/metamoRph/articles/So_many_ways_to_screw_up_PCA_projection.html","id":"good-news-i-did-metamorph","dir":"Articles","previous_headings":"wow, if only someone wrote a R package that could handle all of the issues so I can get on with my analysis!","what":"Good news, I did: metamoRph","title":"So many ways to screw up PCA projection","text":"two steps: run_pca wrapper around prcomp , default, : CPM scale samples log1p scale data remove zero count genes row scale center genes tries remove mitochondrial ribosomal genes often useful scRNA analysis offers two ways select highly variable genes: “scran” uses count scaled variance selection approach (higher expressed genes/features naturally higher variance) “classic” approach just uses matrixStats::rowVar calculates % standard deviation explained PC returns list object prcomp object, parameters chosen, center/scale values, % standard deviation explained PC metamoRph function takes two three inputs: new counts matrix $rotation matrix prcomp optionally center/scale values prcomp align feature/gene names input data rotation matrix scale data directions discussed return $x equivalent PC space Let’s see practice 10x scaled input data tripped stats::predict two two steps: run_pca runs prcomp settings discussed metamoRph takes new data projects onto mm_pca space","code":"library(metamoRph) mm_pca <- run_pca(t(faux_mat), meta = samples |> data.frame(), sample_scale = 'seurat') projected_pca <- metamoRph(t(new_data*10),                                 mm_pca$PCA$rotation,                                 center_scale = mm_pca$center_scale, sample_scale = 'seurat')  bind_rows(as_tibble(faux_pca$x, rownames = 'samples'),       as_tibble(projected_pca, rownames = 'samples')) |>   mutate(samples = gsub('\\\\d','',samples)) |>   ggplot(aes(x=PC1,y=PC2,color=samples)) +    geom_point() +   cowplot::theme_cowplot() sessionInfo() #> R version 4.3.0 (2023-04-21) #> Platform: aarch64-apple-darwin20 (64-bit) #> Running under: macOS Ventura 13.4.1 #>  #> Matrix products: default #> BLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib  #> LAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0 #>  #> locale: #> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 #>  #> time zone: America/New_York #> tzcode source: internal #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] metamoRph_0.2.0 ggplot2_3.4.2   dplyr_1.1.2     #>  #> loaded via a namespace (and not attached): #>  [1] tidyselect_1.2.0            farver_2.1.1                #>  [3] bitops_1.0-7                fastmap_1.1.1               #>  [5] SingleCellExperiment_1.22.0 RCurl_1.98-1.12             #>  [7] bluster_1.9.1               digest_0.6.31               #>  [9] rsvd_1.0.5                  lifecycle_1.0.3             #> [11] cluster_2.1.4               statmod_1.5.0               #> [13] magrittr_2.0.3              compiler_4.3.0              #> [15] rlang_1.1.1                 sass_0.4.6                  #> [17] tools_4.3.0                 igraph_1.4.3                #> [19] utf8_1.2.3                  yaml_2.3.7                  #> [21] knitr_1.43                  dqrng_0.3.0                 #> [23] S4Arrays_1.0.4              labeling_0.4.2              #> [25] DelayedArray_0.26.6         BiocParallel_1.33.11        #> [27] withr_2.5.0                 purrr_1.0.1                 #> [29] BiocGenerics_0.46.0         desc_1.4.2                  #> [31] grid_4.3.0                  stats4_4.3.0                #> [33] fansi_1.0.4                 beachmat_2.15.0             #> [35] colorspace_2.1-0            edgeR_3.42.2                #> [37] scales_1.2.1                SummarizedExperiment_1.30.1 #> [39] cli_3.6.1                   rmarkdown_2.21              #> [41] crayon_1.5.2                ragg_1.2.5                  #> [43] generics_0.1.3              metapod_1.7.0               #> [45] rstudioapi_0.14             DelayedMatrixStats_1.21.0   #> [47] scuttle_1.9.4               cachem_1.0.8                #> [49] stringr_1.5.0               zlibbioc_1.46.0             #> [51] parallel_4.3.0              XVector_0.40.0              #> [53] matrixStats_0.63.0          vctrs_0.6.2                 #> [55] Matrix_1.5-4.1              jsonlite_1.8.4              #> [57] BiocSingular_1.15.0         IRanges_2.34.0              #> [59] S4Vectors_0.38.1            BiocNeighbors_1.17.1        #> [61] irlba_2.3.5.1               systemfonts_1.0.4           #> [63] locfit_1.5-9.7              limma_3.56.1                #> [65] tidyr_1.3.0                 jquerylib_0.1.4             #> [67] glue_1.6.2                  pkgdown_2.0.7               #> [69] codetools_0.2-19            cowplot_1.1.1               #> [71] stringi_1.7.12              gtable_0.3.3                #> [73] GenomeInfoDb_1.36.0         GenomicRanges_1.52.0        #> [75] ScaledMatrix_1.8.1          munsell_0.5.0               #> [77] tibble_3.2.1                pillar_1.9.0                #> [79] htmltools_0.5.5             GenomeInfoDbData_1.2.10     #> [81] R6_2.5.1                    textshaping_0.3.6           #> [83] sparseMatrixStats_1.11.1    rprojroot_2.0.3             #> [85] evaluate_0.21               lattice_0.21-8              #> [87] Biobase_2.60.0              highr_0.10                  #> [89] memoise_2.0.1               scran_1.27.1                #> [91] bslib_0.5.0                 Rcpp_1.0.10                 #> [93] xfun_0.39                   fs_1.6.2                    #> [95] MatrixGenerics_1.12.0       pkgconfig_2.0.3"},{"path":"https://davemcg.github.io/metamoRph/articles/build_a_brain_region_predictor.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Build and Apply a Human Brain Region Predictor in 60 seconds or less","text":"GTEx resource contains thousands human RNA-seq tissues. use recount3 package pull GTEx brain RNA-seq datasets, use subset build brain region predictor, apply remaining GTEx brain data bring outside human brain study see whether model still useful.","code":""},{"path":"https://davemcg.github.io/metamoRph/articles/build_a_brain_region_predictor.html","id":"pull-in-gtex-brain-counts-via-recount3","dir":"Articles","previous_headings":"","what":"Pull in GTEx brain counts via recount3","title":"Build and Apply a Human Brain Region Predictor in 60 seconds or less","text":"longest step vignette. Takes 10-20 seconds, though time vary depending vagaries internet. show gtex.smtsd see brain regions assayed GTEx.","code":"library(ggplot2) library(dplyr) library(recount3) # library(metamoRph) human_projects <- available_projects()  project_info <- subset(human_projects, file_source == \"gtex\" & project_type == \"data_sources\" &     project == \"BRAIN\")  rse_gene_brain <- create_rse(project_info)  colData(rse_gene_brain)$gtex.smtsd %>%     table() #> . #>                          Brain - Amygdala  Brain - Anterior cingulate cortex (BA24)  #>                                       163                                       201  #>           Brain - Caudate (basal ganglia)             Brain - Cerebellar Hemisphere  #>                                       273                                       250  #>                        Brain - Cerebellum                            Brain - Cortex  #>                                       285                                       286  #>              Brain - Frontal Cortex (BA9)                       Brain - Hippocampus  #>                                       224                                       220  #>                      Brain - Hypothalamus Brain - Nucleus accumbens (basal ganglia)  #>                                       221                                       262  #>           Brain - Putamen (basal ganglia)        Brain - Spinal cord (cervical c-1)  #>                                       221                                       171  #>                  Brain - Substantia nigra  #>                                       154"},{"path":"https://davemcg.github.io/metamoRph/articles/build_a_brain_region_predictor.html","id":"extract-read-counts","dir":"Articles","previous_headings":"","what":"Extract read counts","title":"Build and Apply a Human Brain Region Predictor in 60 seconds or less","text":"","code":"brain_counts <- compute_read_counts(rse_gene_brain)"},{"path":"https://davemcg.github.io/metamoRph/articles/build_a_brain_region_predictor.html","id":"build-metadata-table-for-the-train-and-project-data","dir":"Articles","previous_headings":"","what":"Build metadata table for the “train” and “project” data","title":"Build and Apply a Human Brain Region Predictor in 60 seconds or less","text":"train data used build PCA object. PCA data used model building. project data morphed/projected onto PCA space metamoRph output used model_apply guess tissue label. happens less 10 seconds MacBook. find (anecdotally) using fairly large number PC (200 case) tends modestly label transfer performance bulk RNA seq data.","code":"set.seed(20230711) train_meta <- colData(rse_gene_brain) %>%     as_tibble(rownames = \"id\") %>%     group_by(gtex.smtsd) %>%     sample_n(40) project_meta <- colData(rse_gene_brain) %>%     as_tibble(rownames = \"id\") %>%     filter(!id %in% train_meta$id)  train_counts <- brain_counts[, train_meta$id] project_counts <- brain_counts[, project_meta$id]  gtex_pca <- run_pca(train_counts, train_meta)  trained_model <- model_build(gtex_pca$PCA$x, gtex_pca$meta %>%     pull(gtex.smtsd), num_PCs = 200, verbose = FALSE)  projected_data <- metamoRph(project_counts, gtex_pca$PCA$rotation, gtex_pca$center_scale) # apply model label_guesses <- model_apply(trained_model, projected_data, project_meta %>%     pull(gtex.smtsd))"},{"path":"https://davemcg.github.io/metamoRph/articles/build_a_brain_region_predictor.html","id":"accuracy","dir":"Articles","previous_headings":"","what":"Accuracy","title":"Build and Apply a Human Brain Region Predictor in 60 seconds or less","text":"","code":"num_correct <- label_guesses %>%     filter(sample_label == predict) %>%     nrow() num_wrong <- label_guesses %>%     filter(sample_label != predict) %>%     nrow()  # accuracy num_correct/(num_correct + num_wrong) #> [1] 0.9261717"},{"path":"https://davemcg.github.io/metamoRph/articles/build_a_brain_region_predictor.html","id":"visualizing-the-label-outcomes-on-the-pc","dir":"Articles","previous_headings":"","what":"Visualizing the label outcomes on the PC","title":"Build and Apply a Human Brain Region Predictor in 60 seconds or less","text":"can see many “misablels” edge (!) groups.","code":"bind_rows(projected_data %>%     as_tibble(rownames = \"id\")) %>%     left_join(colData(rse_gene_brain) %>%         as_tibble(rownames = \"id\"), by = \"id\") %>%     left_join(label_guesses, by = c(id = \"sample_id\")) %>%     mutate(correct = case_when(sample_label == predict ~ \"Yes\", TRUE ~ \"No\")) %>%     ggplot(aes(x = PC1, y = PC2, color = correct)) + geom_point(alpha = 0.5) + cowplot::theme_cowplot() +     facet_wrap(~gtex.smtsd)"},{"path":"https://davemcg.github.io/metamoRph/articles/build_a_brain_region_predictor.html","id":"now-a-harder-thing---using-outside-data-on-the-model-we-built","dir":"Articles","previous_headings":"","what":"Now a harder thing - using outside data on the model we built","title":"Build and Apply a Human Brain Region Predictor in 60 seconds or less","text":"BA9 prefontal cortex - model built still ~89% accuracy.","code":"# outside brain prefrontal cortex (BA9) outside_gtex <- subset(human_projects, project_type == \"data_sources\" & project == \"SRP058181\") rse_gene_outside <- create_rse(outside_gtex)  outside_counts <- compute_read_counts(rse_gene_outside) outside_meta <- colData(rse_gene_outside) %>%     as_tibble(rownames = \"id\") outside_counts <- outside_counts[, outside_meta$id]   projected_data_outside <- metamoRph(outside_counts, gtex_pca$PCA$rotation, gtex_pca$center_scale) label_guesses_outside <- model_apply(trained_model, projected_data_outside)"},{"path":"https://davemcg.github.io/metamoRph/articles/build_a_brain_region_predictor.html","id":"accuracy-1","dir":"Articles","previous_headings":"Now a harder thing - using outside data on the model we built","what":"Accuracy","title":"Build and Apply a Human Brain Region Predictor in 60 seconds or less","text":"","code":"num_correct <- label_guesses_outside %>%     filter(grepl(\"BA9\", predict)) %>%     nrow() num_wrong <- label_guesses_outside %>%     filter(!grepl(\"BA9\", predict)) %>%     nrow()  # accuracy num_correct/(num_correct + num_wrong) #> [1] 0.8767123"},{"path":"https://davemcg.github.io/metamoRph/articles/build_a_brain_region_predictor.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"Build and Apply a Human Brain Region Predictor in 60 seconds or less","text":"","code":"sessionInfo() #> R version 4.3.0 (2023-04-21) #> Platform: aarch64-apple-darwin20 (64-bit) #> Running under: macOS Ventura 13.4.1 #>  #> Matrix products: default #> BLAS:   /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib  #> LAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0 #>  #> locale: #> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 #>  #> time zone: America/New_York #> tzcode source: internal #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #>  [1] metamoRph_0.2.0             projectR_1.16.0             recount3_1.10.2             SummarizedExperiment_1.30.1 #>  [5] Biobase_2.60.0              GenomicRanges_1.52.0        GenomeInfoDb_1.36.0         IRanges_2.34.0              #>  [9] S4Vectors_0.38.1            BiocGenerics_0.46.0         MatrixGenerics_1.12.0       matrixStats_0.63.0          #> [13] knitr_1.43                  scMerge_1.16.0              patchwork_1.1.2             cowplot_1.1.1               #> [17] ggplot2_3.4.2               uwot_0.1.14                 Matrix_1.5-4.1              dplyr_1.1.2                 #> [21] panc8.SeuratData_3.0.2      SeuratData_0.2.2            SeuratObject_4.1.3          Seurat_4.3.0.1              #>  #> loaded via a namespace (and not attached): #>   [1] R.methodsS3_1.8.2           dichromat_2.0-0.1           progress_1.2.2              #>   [4] urlchecker_1.0.1            nnet_7.3-19                 goftest_1.2-3               #>   [7] Biostrings_2.67.2           rstan_2.21.8                vctrs_0.6.2                 #>  [10] spatstat.random_3.1-5       digest_0.6.31               png_0.1-8                   #>  [13] registry_0.5-1              ggrepel_0.9.3               deldir_1.0-9                #>  [16] parallelly_1.36.0           batchelor_1.15.1            MASS_7.3-60                 #>  [19] pkgdown_2.0.7               tictoc_1.2                  reshape2_1.4.4              #>  [22] foreach_1.5.2               httpuv_1.6.11               withr_2.5.0                 #>  [25] xfun_0.39                   ellipsis_0.3.2              survival_3.5-5              #>  [28] commonmark_1.9.0            memoise_2.0.1               proxyC_0.3.3                #>  [31] rcmdcheck_1.4.0             ggbeeswarm_0.7.2            profvis_0.3.8               #>  [34] zoo_1.8-12                  gtools_3.9.4                pbapply_1.7-2               #>  [37] R.oo_1.25.0                 DEoptimR_1.1-0              Formula_1.2-5               #>  [40] prettyunits_1.1.1           KEGGREST_1.39.0             promises_1.2.0.1            #>  [43] httr_1.4.6                  restfulr_0.0.15             rhdf5filters_1.12.1         #>  [46] globals_0.16.2              fitdistrplus_1.1-11         cvTools_0.3.2               #>  [49] rhdf5_2.44.0                ps_1.7.5                    rstudioapi_0.14             #>  [52] miniUI_0.1.1.1              generics_0.1.3              ggalluvial_0.12.5           #>  [55] base64enc_0.1-3             processx_3.8.1              babelgene_22.9              #>  [58] curl_5.0.0                  zlibbioc_1.46.0             sfsmisc_1.1-15              #>  [61] ScaledMatrix_1.8.1          polyclip_1.10-4             xopen_1.0.0                 #>  [64] GenomeInfoDbData_1.2.10     doParallel_1.0.17           xtable_1.8-4                #>  [67] stringr_1.5.0               desc_1.4.2                  evaluate_0.21               #>  [70] S4Arrays_1.0.4              BiocFileCache_2.7.2         hms_1.1.3                   #>  [73] irlba_2.3.5.1               colorspace_2.1-0            filelock_1.0.2              #>  [76] ROCR_1.0-11                 CoGAPS_3.19.1               reticulate_1.28             #>  [79] spatstat.data_3.0-1         magrittr_2.0.3              lmtest_0.9-40               #>  [82] later_1.3.1                 viridis_0.6.3               lattice_0.21-8              #>  [85] mapproj_1.2.11              NMF_0.26                    spatstat.geom_3.2-2         #>  [88] future.apply_1.11.0         robustbase_0.99-0           scattermore_1.1             #>  [91] XML_3.99-0.14               scuttle_1.9.4               RcppAnnoy_0.0.20            #>  [94] Hmisc_5.1-0                 pillar_1.9.0                StanHeaders_2.26.27         #>  [97] nlme_3.1-162                iterators_1.0.14            gridBase_0.4-7              #> [100] caTools_1.18.2              compiler_4.3.0              beachmat_2.15.0             #> [103] stringi_1.7.12              tensor_1.5                  devtools_2.4.5              #> [106] GenomicAlignments_1.35.1    plyr_1.8.8                  msigdbr_7.5.1               #> [109] crayon_1.5.2                abind_1.4-5                 BiocIO_1.9.2                #> [112] scater_1.28.0               locfit_1.5-9.7              pals_1.7                    #> [115] sp_2.0-0                    bit_4.0.5                   fastmatch_1.1-3             #> [118] codetools_0.2-19            BiocSingular_1.15.0         bslib_0.5.0                 #> [121] plotly_4.10.1               mime_0.12                   splines_4.3.0               #> [124] Rcpp_1.0.10                 dbplyr_2.3.2                sparseMatrixStats_1.11.1    #> [127] blob_1.2.4                  utf8_1.2.3                  reldist_1.7-2               #> [130] fs_1.6.2                    listenv_0.9.0               checkmate_2.2.0             #> [133] DelayedMatrixStats_1.21.0   pkgbuild_1.4.0              tibble_3.2.1                #> [136] callr_3.7.3                 statmod_1.5.0               tweenr_2.0.2                #> [139] startupmsg_0.9.6            pkgconfig_2.0.3             tools_4.3.0                 #> [142] cachem_1.0.8                RSQLite_2.3.1               viridisLite_0.4.2           #> [145] DBI_1.1.3                   numDeriv_2016.8-1.1         fastmap_1.1.1               #> [148] rmarkdown_2.21              scales_1.2.1                grid_4.3.0                  #> [151] usethis_2.1.6               ica_1.0-3                   Rsamtools_2.15.2            #> [154] sass_0.4.6                  BiocManager_1.30.20         RANN_2.6.1                  #> [157] rpart_4.1.19                farver_2.1.1                mgcv_1.8-42                 #> [160] yaml_2.3.7                  roxygen2_7.2.3              foreign_0.8-84              #> [163] rtracklayer_1.59.1          cli_3.6.1                   purrr_1.0.1                 #> [166] leiden_0.4.3                lifecycle_1.0.3             M3Drop_1.26.0               #> [169] mvtnorm_1.1-3               bluster_1.9.1               sessioninfo_1.2.2           #> [172] backports_1.4.1             BiocParallel_1.33.11        distr_2.9.2                 #> [175] gtable_0.3.3                rjson_0.2.21                ggridges_0.5.4              #> [178] densEstBayes_1.0-2.2        progressr_0.13.0            testthat_3.1.8              #> [181] parallel_4.3.0              limma_3.56.1                jsonlite_1.8.4              #> [184] edgeR_3.42.2                bitops_1.0-7                bit64_4.0.5                 #> [187] brio_1.1.3                  Rtsne_0.16                  spatstat.utils_3.0-3        #> [190] BiocNeighbors_1.17.1        RcppParallel_5.1.7          bdsmatrix_1.3-6             #> [193] jquerylib_0.1.4             highr_0.10                  metapod_1.7.0               #> [196] dqrng_0.3.0                 loo_2.6.0                   R.utils_2.12.2              #> [199] lazyeval_0.2.2              shiny_1.7.4                 ruv_0.9.7.1                 #> [202] htmltools_0.5.5             sctransform_0.3.5           rappdirs_0.3.3              #> [205] formatR_1.14                glue_1.6.2                  ResidualMatrix_1.10.0       #> [208] XVector_0.40.0              RCurl_1.98-1.12             rprojroot_2.0.3             #> [211] scran_1.27.1                gridExtra_2.3               igraph_1.4.3                #> [214] R6_2.5.1                    tidyr_1.3.0                 SingleCellExperiment_1.22.0 #> [217] gplots_3.1.3                forcats_1.0.0               labeling_0.4.2              #> [220] rngtools_1.5.2              cluster_2.1.4               bbmle_1.0.25                #> [223] Rhdf5lib_1.22.0             pkgload_1.3.2               rstantools_2.3.1            #> [226] DelayedArray_0.26.6         tidyselect_1.2.0            vipor_0.4.5                 #> [229] htmlTable_2.4.1             maps_3.4.1                  ggforce_0.4.1               #> [232] xml2_1.3.4                  inline_0.3.19               AnnotationDbi_1.61.2        #> [235] future_1.32.0               rsvd_1.0.5                  munsell_0.5.0               #> [238] KernSmooth_2.23-21          data.table_1.14.8           fgsea_1.25.0                #> [241] htmlwidgets_1.6.2           RColorBrewer_1.1-3          biomaRt_2.55.0              #> [244] rlang_1.1.1                 spatstat.sparse_3.0-2       spatstat.explore_3.2-1      #> [247] remotes_2.4.2               fansi_1.0.4                 beeswarm_0.4.0"},{"path":"https://davemcg.github.io/metamoRph/articles/dataset_integration_and_projection.html","id":"motivation","dir":"Articles","previous_headings":"","what":"Motivation","title":"Batch Corrected metamoRph Reference","text":"want build batch corrected scRNA-seq reference several disparate datasets use resource label transfer visualization onto new data.","code":""},{"path":"https://davemcg.github.io/metamoRph/articles/dataset_integration_and_projection.html","id":"so","dir":"Articles","previous_headings":"","what":"So…","title":"Batch Corrected metamoRph Reference","text":"metamoRph batch correction tool. Just small set functions enable projection data onto existing reference resource. Using disparate set scRNA datasets metamoRph::run_pca requires datasets batch corrected. present two approaches: one using Seurat’s IntegrateData another scMerge2 generate corrected counts. demonstrate applicability metamoRph can extend beyond data cherry picking variety ocular resources curated, use data Seurat’s Mapping annotating query datasets guide.","code":""},{"path":"https://davemcg.github.io/metamoRph/articles/dataset_integration_and_projection.html","id":"why-not-just-use-seurat-the-whole-way-through","dir":"Articles","previous_headings":"","what":"Why not just use Seurat the whole way through?????","title":"Batch Corrected metamoRph Reference","text":"Seurat full set tools just everything - including batch correction, projecting new data onto , transfer labels make matching UMAP. code reproduced first code chunk. even bother using metamoRph? two reasons. First, metamoRph general projection engine. can use bulk RNA. can use scRNA. reason can’t use kinds information! PCA (SVD) tremendous dimensionality reduction approaches find amazing , touch attention data preprocessing, can project (morph!) new data onto existing PCA space just matrix multiplication. second speed. approach simple, built reference, can morph new data label transfer second(s).","code":""},{"path":"https://davemcg.github.io/metamoRph/articles/dataset_integration_and_projection.html","id":"why-cant-i-use-the-pca-i-already-made-with-seurat","dir":"Articles","previous_headings":"","what":"Why can’t I use the PCA I already made with Seurat?","title":"Batch Corrected metamoRph Reference","text":"Unfortunately can’t use Seurat PCA return center scaling values used internal data normalization. bog standard prcomp function return values, PCA using prcomp (inspired prcomp) values can extracted returned object metamoRph::extract_prcomp_scaling().","code":""},{"path":"https://davemcg.github.io/metamoRph/articles/dataset_integration_and_projection.html","id":"package-loads","dir":"Articles","previous_headings":"","what":"Package Loads","title":"Batch Corrected metamoRph Reference","text":"","code":"library(Seurat) library(SeuratData) library(dplyr) library(uwot) library(ggplot2) library(cowplot) library(patchwork) library(metamoRph) library(scMerge) # InstallData('panc8')"},{"path":"https://davemcg.github.io/metamoRph/articles/dataset_integration_and_projection.html","id":"seurat-dataset-integration","dir":"Articles","previous_headings":"","what":"Seurat Dataset Integration","title":"Batch Corrected metamoRph Reference","text":"code taken Seurat v4 Mapping annotating query datasets guide. git link guide , previous link go dead guide substantially changed future.","code":""},{"path":"https://davemcg.github.io/metamoRph/articles/dataset_integration_and_projection.html","id":"integrate","dir":"Articles","previous_headings":"Seurat Dataset Integration","what":"Integrate","title":"Batch Corrected metamoRph Reference","text":"","code":"data(\"panc8\")  pancreas.list <- SplitObject(panc8, split.by = \"tech\") pancreas.list <- pancreas.list[c(\"celseq\", \"celseq2\", \"fluidigmc1\", \"smartseq2\")]  tictoc::tic() for (i in 1:length(pancreas.list)) {     pancreas.list[[i]] <- NormalizeData(pancreas.list[[i]], verbose = FALSE)     pancreas.list[[i]] <- FindVariableFeatures(pancreas.list[[i]], selection.method = \"vst\", nfeatures = 2000,         verbose = FALSE) }   reference.list <- pancreas.list[c(\"celseq\", \"celseq2\", \"smartseq2\")] pancreas.anchors <- FindIntegrationAnchors(object.list = reference.list, dims = 1:30)  pancreas.integrated <- IntegrateData(anchorset = pancreas.anchors, dims = 1:30) seurat_integration_timing <- tictoc::toc()"},{"path":"https://davemcg.github.io/metamoRph/articles/dataset_integration_and_projection.html","id":"map-new-data-onto-reference","dir":"Articles","previous_headings":"Seurat Dataset Integration","what":"Map New Data Onto Reference","title":"Batch Corrected metamoRph Reference","text":"Seurat’s approach results 617 correct labels 21 incorrect. Given UMAP viz (cue Lior Pachter screaming) probably “incorrect” mislabels.","code":"tictoc::tic() # switch to integrated assay. The variable features of this assay are automatically set during # IntegrateData DefaultAssay(pancreas.integrated) <- \"integrated\" # Run the standard workflow for visualization and clustering pancreas.integrated <- ScaleData(pancreas.integrated, verbose = FALSE) pancreas.integrated <- RunPCA(pancreas.integrated, npcs = 30, verbose = FALSE) pancreas.integrated <- RunUMAP(pancreas.integrated, reduction = \"pca\", dims = 1:30, verbose = FALSE) seurat_rebuild_analysis_on_corrected_data_timing <- tictoc::toc() #> 11.603 sec elapsed # p1 <- DimPlot(pancreas.integrated, reduction = 'umap', group.by = 'tech') p2 <- # DimPlot(pancreas.integrated, reduction = 'umap', group.by = 'celltype', label = TRUE, repel # = TRUE) + NoLegend() p1 + p2  tictoc::tic()  # project new data onto reference and build matching umap pancreas.query <- pancreas.list[[\"fluidigmc1\"]] pancreas.anchors <- FindTransferAnchors(reference = pancreas.integrated, query = pancreas.query,     dims = 1:30, reference.reduction = \"pca\") predictions <- TransferData(anchorset = pancreas.anchors, refdata = pancreas.integrated$celltype,     dims = 1:30) pancreas.query <- AddMetaData(pancreas.query, metadata = predictions)  pancreas.integrated <- RunUMAP(pancreas.integrated, dims = 1:30, reduction = \"pca\", return.model = TRUE) pancreas.query <- MapQuery(anchorset = pancreas.anchors, reference = pancreas.integrated, query = pancreas.query,     refdata = list(celltype = \"celltype\"), reference.reduction = \"pca\", reduction.model = \"umap\")  pancreas.query$prediction.match <- pancreas.query$predicted.id == pancreas.query$celltype table(pancreas.query$prediction.match) #>  #> FALSE  TRUE  #>    21   617 seurat_default_accuracy <- sum(pancreas.query$prediction.match)/length(pancreas.query$prediction.match)  # end timing BEFOFE the plotting step so we don't also compare plotting efficiency seurat_projection_timing <- tictoc::toc() #> 15.274 sec elapsed  p1 <- DimPlot(pancreas.integrated, reduction = \"umap\", group.by = \"celltype\", label = TRUE, label.size = 3,     repel = TRUE) + NoLegend() + ggtitle(\"Reference annotations\") p2 <- DimPlot(pancreas.query, reduction = \"ref.umap\", group.by = \"predicted.celltype\", label = TRUE,     label.size = 3, repel = TRUE) + NoLegend() + ggtitle(\"Query transferred labels\")   p1 + p2"},{"path":"https://davemcg.github.io/metamoRph/articles/dataset_integration_and_projection.html","id":"leverage-seurats-corrected-counts-in-metamorph","dir":"Articles","previous_headings":"","what":"Leverage Seurat’s Corrected Counts in metamoRph","title":"Batch Corrected metamoRph Reference","text":"first approach demonstrate directly use Seurat’s corrected counts code chunk building “metamoRph” reference projecting/morphing new data onto . Read commented lines code block see explanations certain parameters used metamoRph.","code":"tictoc::tic()  # here we pull the corrected counts from the `integrated` slot and use it as the reference # data NOTE 1: see how we have TURNED OFF NORMALIZATION as the data already is normalized NOTE # 2: we have changed ntop from the default of 1000 to 2000 to match what Seurat uses in their # example reference_obj <- metamoRph::run_pca(pancreas.integrated@assays$integrated@data, meta = pancreas.integrated@meta.data,     method = \"irlba\", normalization = FALSE, irlba_n = 30, ntop = 2000) # Seurat and scran both use cosine instead of euclidean as the metric see also how we have the # full umap model returned this is required downstream ref_umap <- uwot::umap(reference_obj$PCA$x[, 1:30], metric = \"cosine\", ret_model = TRUE) metamoRph_build_ref_from_seurat_counts <- tictoc::toc() #> 19.22 sec elapsed  # plotting code first we are going to stick some of the first lines into a little function to # reduce copy/pasting for the later plots  quick_plotter <- function(umap_data, matching_metadata, point_color = \"celltype\") {     matching_metadata$group <- matching_metadata[, point_color]     umap_data %>%         as_tibble(rownames = \"bc\") %>%         left_join(matching_metadata %>%             as_tibble(rownames = \"bc\")) %>%         ggplot(aes(x = V1, y = V2, color = group)) + geom_point(size = 1) + ggrepel::geom_text_repel(data = . %>%         group_by(group) %>%         summarise(V1 = mean(V1), V2 = mean(V2)), aes(label = group, color = group), alpha = 0.9,         bg.color = \"white\") + cowplot::theme_cowplot() + xlab(\"\") + ylab(\"\") + scale_color_manual(values = pals::glasbey() %>%         unname()) + theme(legend.position = \"none\") } a <- quick_plotter(ref_umap$embedding, pancreas.integrated@meta.data, \"celltype\") + ggtitle(\"Reference: celseq, celseq2, smartseq2\") tictoc::tic()  # here is where we take the new/query data `pancreas.query` and yank out the raw counts we # specify that metamoRph should transform the counts data using the 'Seurat' approach instead # of the default 'cpm' approach query_morphed <- metamoRph::metamoRph(pancreas.query@assays$RNA@counts, reference_obj$PCA$rotation[,     1:30], center_scale = reference_obj$center_scale, sample_scale = \"seurat\") # now we use the reference data PCA ($PCA$x slot) in our model builder to build a cell type # label guesser from the known labels 'reference_obj$meta$celltype' ml <- metamoRph::model_build(reference_obj$PCA$x[, 1:30], reference_obj$meta$celltype) # now we use the models we built to apply to the new data's metamoRph projected PCA space ma <- metamoRph::model_apply(ml, query_morphed, pancreas.query@meta.data$celltype)  seurat_metamorph_accuracy <- ma %>%     filter(sample_label == predict) %>%     nrow()/ma %>%     filter(!is.na(sample_label)) %>%     nrow() paste(\"Accuracy:\", seurat_metamorph_accuracy) #> [1] \"Accuracy: 0.946708463949843\"  paste(\"# Correct:\", ma %>%     filter(sample_label == predict) %>%     nrow()) #> [1] \"# Correct: 604\" paste(\"# Wrong:\", ma %>%     filter(sample_label != predict) %>%     nrow()) #> [1] \"# Wrong: 34\"   umap_proj <- umap_transform(query_morphed[, 1:30], ref_umap)  seurat_metamorph_project_timing <- tictoc::toc() #> 0.681 sec elapsed  b <- quick_plotter(umap_proj, pancreas.query@meta.data, \"celltype\") + ggtitle(\"Query: fluidigmc1\")   cowplot::plot_grid(a, b)"},{"path":"https://davemcg.github.io/metamoRph/articles/dataset_integration_and_projection.html","id":"scmerge2-batch-correction-as-input-to-metamorph","dir":"Articles","previous_headings":"","what":"scMerge2 Batch Correction as Input to metamoRph","title":"Batch Corrected metamoRph Reference","text":"different approach . Seurat used . Instead give raw counts metamoRph::normalize_data used internally metamoRph::run_pca library log1p normalize counts required scMerge2. find top 2000 HVG feed matrix scMerge2 generate batch correct counts. use batch corrected counts build metamoRph PCA reference, project/morph new data . use projected/morphed PCA space make new UMAP move labels , done earlier.","code":"# metaMorph tictoc::tic() # cpm and log1p norm the data dat <- metamoRph::normalize_data(cbind(pancreas.list[[1]]@assays$RNA@counts, pancreas.list[[2]]@assays$RNA@counts,     pancreas.list[[3]]@assays$RNA@counts))  meta <- rbind(pancreas.list[[1]]@meta.data, pancreas.list[[2]]@meta.data, pancreas.list[[3]]@meta.data) # identify the top 2000 HVG hvg_genes <- metamoRph::select_HVG(dat, ntop = 2000) # make corrected expression matrix Note: we turn off the unneeded cosineNorm scmerge_correction <- scMerge2(dat[hvg_genes, ], batch = meta$tech, cosineNorm = FALSE, cellTypes = meta$celltype,     verbose = FALSE, seed = \"2023.0723\") # pull corrected matrix out of the scmerge2 object corrected_dat <- scmerge_correction$newY # again we turn off normalization as the scmerge corrected data has already been cpm and log1p # normalized scmerge2_batch_cor_timing <- tictoc::toc() #> 11.732 sec elapsed  tictoc::tic() reference_obj <- metamoRph::run_pca(corrected_dat, meta = meta, method = \"irlba\", irlba_n = 30,     normalization = FALSE, ntop = 2000)    # run umap ref_umap_scMerge2 <- uwot::umap(reference_obj$PCA$x[, 1:30], metric = \"cosine\", ret_model = TRUE) metamoRph_ref_with_scmerge2_correct_counts <- tictoc::toc() #> 23.642 sec elapsed a <- quick_plotter(ref_umap_scMerge2$embedding, pancreas.integrated@meta.data, \"celltype\") + ggtitle(\"Reference: celseq, celseq2, smartseq2\") # create projected PCA space with the new data via metamoRph's matrix multplication  tictoc::tic() query_morphed <- metamoRph::metamoRph(pancreas.query@assays$RNA@counts, reference_obj$PCA$rotation[,     1:30], center_scale = reference_obj$center_scale)     # build cell type label model ml <- metamoRph::model_build(data.frame(reference_obj$PCA$x[, 1:30]), meta$celltype) # apply the model ma <- metamoRph::model_apply(ml, query_morphed, pancreas.query@meta.data$celltype)  scmerge2_metamorph_accuracy <- ma %>%     filter(sample_label == predict) %>%     nrow()/ma %>%     filter(!is.na(sample_label)) %>%     nrow() paste(\"Accuracy:\", scmerge2_metamorph_accuracy) #> [1] \"Accuracy: 0.970219435736677\" paste(\"# Correct:\", ma %>%     filter(sample_label == predict) %>%     nrow()) #> [1] \"# Correct: 619\" paste(\"# Wrong:\", ma %>%     filter(sample_label != predict) %>%     nrow()) #> [1] \"# Wrong: 19\"  # project the morphed PCA space of the new data onto the existing PCA we built above umap_proj <- umap_transform(query_morphed[, 1:30], ref_umap)  b <- quick_plotter(umap_proj, pancreas.query@meta.data, \"celltype\") + ggtitle(\"Query: fluidigmc1\")   cowplot::plot_grid(a, b) metamorph_scmerge2_morph_timing <- tictoc::toc() #> 0.97 sec elapsed"},{"path":"https://davemcg.github.io/metamoRph/articles/dataset_integration_and_projection.html","id":"timings","dir":"Articles","previous_headings":"","what":"Timings","title":"Batch Corrected metamoRph Reference","text":"Full Seurat slowest approach. metamoRph BATCH CORRECTION tool thus nothing record “Batch Correction” category metamoRph. Building reference data Seurat 2x faster metamoRph. plan trying figure case. theory expect approximately . Projecting new data onto reference 20x faster metamoRph compared Seurat.","code":"batch_correction_timing <- c(substr(seurat_integration_timing$callback_msg, 1, 4) %>%     as.numeric(), substr(scmerge2_batch_cor_timing$callback_msg, 1, 4) %>%     as.numeric()) names(batch_correction_timing) <- c(\"Seurat\", \"scMerge2\")  build_reference <- c(substr(seurat_rebuild_analysis_on_corrected_data_timing$callback_msg, 1, 4) %>%     as.numeric(), substr(metamoRph_build_ref_from_seurat_counts$callback_msg, 1, 4) %>%     as.numeric(), substr(metamoRph_ref_with_scmerge2_correct_counts$callback_msg, 1, 4) %>%     as.numeric())  names(build_reference) <- c(\"Seurat\", \"metamoRph (Seurat origin)\", \"metamoRph (scMerge2 origin)\")  projection_timing <- c(substr(seurat_projection_timing$callback_msg, 1, 4) %>%     as.numeric(), substr(seurat_metamorph_project_timing$callback_msg, 1, 4) %>%     as.numeric(), substr(metamorph_scmerge2_morph_timing$callback_msg, 1, 4) %>%     as.numeric()) names(projection_timing) <- c(\"Seurat\", \"metamoRph (Seurat origin)\", \"metamoRph (scMerge2 origin)\")   bind_rows(data.frame(batch_correction_timing) %>%     as_tibble(rownames = \"Method\") %>%     mutate(Step = \"Batch Correction\") %>%     dplyr::rename(time = batch_correction_timing), data.frame(build_reference) %>%     as_tibble(rownames = \"Method\") %>%     mutate(Step = \"Build Reference\") %>%     dplyr::rename(time = build_reference), data.frame(projection_timing) %>%     as_tibble(rownames = \"Method\") %>%     mutate(Step = \"Query Projection\") %>%     dplyr::rename(time = projection_timing)) %>%     mutate(Method = factor(Method, levels = c(\"Seurat\", \"metamoRph*\", \"scMerge2\", \"metamoRph (Seurat origin)\",         \"metamoRph (scMerge2 origin)\") %>%         rev())) %>%     ggplot(aes(y = Method, x = time)) + geom_bar(stat = \"identity\") + facet_wrap(~Step, scales = \"free_y\") +     xlab(\"Time (seconds)\") + geom_text(aes(label = time), hjust = \"inward\", color = \"orange\", size = 6) +     cowplot::theme_cowplot()"},{"path":"https://davemcg.github.io/metamoRph/articles/dataset_integration_and_projection.html","id":"accuracy-of-label-transfer","dir":"Articles","previous_headings":"","what":"Accuracy of Label Transfer","title":"Batch Corrected metamoRph Reference","text":"three approaches highly similar accuracy. guess getting really nit picky Seurat counts used metamoRph touch worse full Seurat scMerge2/Seurat approach bit better. work pretty well opinion.","code":"accuracy <- c(seurat_default_accuracy, seurat_metamorph_accuracy, scmerge2_metamorph_accuracy) %>%     data.frame() accuracy$method <- c(\"Seurat\", \"metamoRph (Seurat origin)\", \"metamoRph (scMerge2 origin)\") colnames(accuracy) <- c(\"Accuracy\", \"Method\") accuracy %>%     mutate(Accuracy = Accuracy * 100) %>%     ggplot(aes(y = Method, x = Accuracy)) + geom_bar(stat = \"identity\") + geom_text(aes(label = round(Accuracy,     2)), hjust = \"inward\", color = \"orange\", size = 6) + cowplot::theme_cowplot() + ylab(\"Method\") +     xlab(\"% Correct Transferred Cell Type Labels\") + coord_cartesian(xlim = c(0, 100))"},{"path":"https://davemcg.github.io/metamoRph/articles/dataset_integration_and_projection.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"Batch Corrected metamoRph Reference","text":"","code":"sessionInfo() #> R version 4.3.0 (2023-04-21) #> Platform: aarch64-apple-darwin20 (64-bit) #> Running under: macOS Ventura 13.4.1 #>  #> Matrix products: default #> BLAS:   /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib  #> LAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0 #>  #> locale: #> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 #>  #> time zone: America/New_York #> tzcode source: internal #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #>  [1] metamoRph_0.2.0             projectR_1.16.0             recount3_1.10.2             SummarizedExperiment_1.30.1 #>  [5] Biobase_2.60.0              GenomicRanges_1.52.0        GenomeInfoDb_1.36.0         IRanges_2.34.0              #>  [9] S4Vectors_0.38.1            BiocGenerics_0.46.0         MatrixGenerics_1.12.0       matrixStats_0.63.0          #> [13] knitr_1.43                  scMerge_1.16.0              patchwork_1.1.2             cowplot_1.1.1               #> [17] ggplot2_3.4.2               uwot_0.1.14                 Matrix_1.5-4.1              dplyr_1.1.2                 #> [21] panc8.SeuratData_3.0.2      SeuratData_0.2.2            SeuratObject_4.1.3          Seurat_4.3.0.1              #>  #> loaded via a namespace (and not attached): #>   [1] R.methodsS3_1.8.2           dichromat_2.0-0.1           progress_1.2.2              #>   [4] urlchecker_1.0.1            nnet_7.3-19                 goftest_1.2-3               #>   [7] Biostrings_2.67.2           rstan_2.21.8                vctrs_0.6.2                 #>  [10] spatstat.random_3.1-5       digest_0.6.31               png_0.1-8                   #>  [13] registry_0.5-1              ggrepel_0.9.3               deldir_1.0-9                #>  [16] parallelly_1.36.0           batchelor_1.15.1            MASS_7.3-60                 #>  [19] pkgdown_2.0.7               tictoc_1.2                  reshape2_1.4.4              #>  [22] foreach_1.5.2               httpuv_1.6.11               withr_2.5.0                 #>  [25] xfun_0.39                   ellipsis_0.3.2              survival_3.5-5              #>  [28] commonmark_1.9.0            memoise_2.0.1               proxyC_0.3.3                #>  [31] rcmdcheck_1.4.0             ggbeeswarm_0.7.2            profvis_0.3.8               #>  [34] zoo_1.8-12                  gtools_3.9.4                pbapply_1.7-2               #>  [37] R.oo_1.25.0                 DEoptimR_1.1-0              Formula_1.2-5               #>  [40] prettyunits_1.1.1           KEGGREST_1.39.0             promises_1.2.0.1            #>  [43] httr_1.4.6                  restfulr_0.0.15             rhdf5filters_1.12.1         #>  [46] globals_0.16.2              fitdistrplus_1.1-11         cvTools_0.3.2               #>  [49] rhdf5_2.44.0                ps_1.7.5                    rstudioapi_0.14             #>  [52] miniUI_0.1.1.1              generics_0.1.3              ggalluvial_0.12.5           #>  [55] base64enc_0.1-3             processx_3.8.1              babelgene_22.9              #>  [58] curl_5.0.0                  zlibbioc_1.46.0             sfsmisc_1.1-15              #>  [61] ScaledMatrix_1.8.1          polyclip_1.10-4             xopen_1.0.0                 #>  [64] GenomeInfoDbData_1.2.10     doParallel_1.0.17           xtable_1.8-4                #>  [67] stringr_1.5.0               desc_1.4.2                  evaluate_0.21               #>  [70] S4Arrays_1.0.4              BiocFileCache_2.7.2         hms_1.1.3                   #>  [73] irlba_2.3.5.1               colorspace_2.1-0            filelock_1.0.2              #>  [76] ROCR_1.0-11                 CoGAPS_3.19.1               reticulate_1.28             #>  [79] spatstat.data_3.0-1         magrittr_2.0.3              lmtest_0.9-40               #>  [82] later_1.3.1                 viridis_0.6.3               lattice_0.21-8              #>  [85] mapproj_1.2.11              NMF_0.26                    spatstat.geom_3.2-2         #>  [88] future.apply_1.11.0         robustbase_0.99-0           scattermore_1.1             #>  [91] XML_3.99-0.14               scuttle_1.9.4               RcppAnnoy_0.0.20            #>  [94] Hmisc_5.1-0                 pillar_1.9.0                StanHeaders_2.26.27         #>  [97] nlme_3.1-162                iterators_1.0.14            gridBase_0.4-7              #> [100] caTools_1.18.2              compiler_4.3.0              beachmat_2.15.0             #> [103] stringi_1.7.12              tensor_1.5                  devtools_2.4.5              #> [106] GenomicAlignments_1.35.1    plyr_1.8.8                  msigdbr_7.5.1               #> [109] crayon_1.5.2                abind_1.4-5                 BiocIO_1.9.2                #> [112] scater_1.28.0               locfit_1.5-9.7              pals_1.7                    #> [115] sp_2.0-0                    bit_4.0.5                   fastmatch_1.1-3             #> [118] codetools_0.2-19            BiocSingular_1.15.0         bslib_0.5.0                 #> [121] plotly_4.10.1               mime_0.12                   splines_4.3.0               #> [124] Rcpp_1.0.10                 dbplyr_2.3.2                sparseMatrixStats_1.11.1    #> [127] blob_1.2.4                  utf8_1.2.3                  reldist_1.7-2               #> [130] fs_1.6.2                    listenv_0.9.0               checkmate_2.2.0             #> [133] DelayedMatrixStats_1.21.0   pkgbuild_1.4.0              tibble_3.2.1                #> [136] callr_3.7.3                 statmod_1.5.0               tweenr_2.0.2                #> [139] startupmsg_0.9.6            pkgconfig_2.0.3             tools_4.3.0                 #> [142] cachem_1.0.8                RSQLite_2.3.1               viridisLite_0.4.2           #> [145] DBI_1.1.3                   numDeriv_2016.8-1.1         fastmap_1.1.1               #> [148] rmarkdown_2.21              scales_1.2.1                grid_4.3.0                  #> [151] usethis_2.1.6               ica_1.0-3                   Rsamtools_2.15.2            #> [154] sass_0.4.6                  BiocManager_1.30.20         RANN_2.6.1                  #> [157] rpart_4.1.19                farver_2.1.1                mgcv_1.8-42                 #> [160] yaml_2.3.7                  roxygen2_7.2.3              foreign_0.8-84              #> [163] rtracklayer_1.59.1          cli_3.6.1                   purrr_1.0.1                 #> [166] leiden_0.4.3                lifecycle_1.0.3             M3Drop_1.26.0               #> [169] mvtnorm_1.1-3               bluster_1.9.1               sessioninfo_1.2.2           #> [172] backports_1.4.1             BiocParallel_1.33.11        distr_2.9.2                 #> [175] gtable_0.3.3                rjson_0.2.21                ggridges_0.5.4              #> [178] densEstBayes_1.0-2.2        progressr_0.13.0            testthat_3.1.8              #> [181] parallel_4.3.0              limma_3.56.1                jsonlite_1.8.4              #> [184] edgeR_3.42.2                bitops_1.0-7                bit64_4.0.5                 #> [187] brio_1.1.3                  Rtsne_0.16                  spatstat.utils_3.0-3        #> [190] BiocNeighbors_1.17.1        RcppParallel_5.1.7          bdsmatrix_1.3-6             #> [193] jquerylib_0.1.4             highr_0.10                  metapod_1.7.0               #> [196] dqrng_0.3.0                 loo_2.6.0                   R.utils_2.12.2              #> [199] lazyeval_0.2.2              shiny_1.7.4                 ruv_0.9.7.1                 #> [202] htmltools_0.5.5             sctransform_0.3.5           rappdirs_0.3.3              #> [205] formatR_1.14                glue_1.6.2                  ResidualMatrix_1.10.0       #> [208] XVector_0.40.0              RCurl_1.98-1.12             rprojroot_2.0.3             #> [211] scran_1.27.1                gridExtra_2.3               igraph_1.4.3                #> [214] R6_2.5.1                    tidyr_1.3.0                 SingleCellExperiment_1.22.0 #> [217] gplots_3.1.3                forcats_1.0.0               labeling_0.4.2              #> [220] rngtools_1.5.2              cluster_2.1.4               bbmle_1.0.25                #> [223] Rhdf5lib_1.22.0             pkgload_1.3.2               rstantools_2.3.1            #> [226] DelayedArray_0.26.6         tidyselect_1.2.0            vipor_0.4.5                 #> [229] htmlTable_2.4.1             maps_3.4.1                  ggforce_0.4.1               #> [232] xml2_1.3.4                  inline_0.3.19               AnnotationDbi_1.61.2        #> [235] future_1.32.0               rsvd_1.0.5                  munsell_0.5.0               #> [238] KernSmooth_2.23-21          data.table_1.14.8           fgsea_1.25.0                #> [241] htmlwidgets_1.6.2           RColorBrewer_1.1-3          biomaRt_2.55.0              #> [244] rlang_1.1.1                 spatstat.sparse_3.0-2       spatstat.explore_3.2-1      #> [247] remotes_2.4.2               fansi_1.0.4                 beeswarm_0.4.0"},{"path":"https://davemcg.github.io/metamoRph/articles/morph_scRNA_query_onto_reference.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Transfer Labels from a Retina scRNA Reference onto a Query Dataset","text":"discuss data projection (morphing! branding!), two primary kinds data. First, reference, previously analyzed labelled. Second query, new data wish speed understanding transferring knowledge (like cell type tissue label) reference.","code":""},{"path":"https://davemcg.github.io/metamoRph/articles/morph_scRNA_query_onto_reference.html","id":"metamorph","dir":"Articles","previous_headings":"","what":"metamoRph","title":"Transfer Labels from a Retina scRNA Reference onto a Query Dataset","text":"package four primary functions:","code":""},{"path":"https://davemcg.github.io/metamoRph/articles/morph_scRNA_query_onto_reference.html","id":"metamorphrun_pca","dir":"Articles","previous_headings":"","what":"metamoRph::run_pca","title":"Transfer Labels from a Retina scRNA Reference onto a Query Dataset","text":"takes raw count data, matched meta data, outputs list object containing prcomp object extra information: percent standard deviation explained PC, center_scale list center scale values calculated prcomp needed properly normalize query data, meta data , finally parameters given metamoRph::run_pca","code":"library(Seurat) # library(metamoRph) library(dplyr) library(uwot) library(ggplot2) tictoc::tic() # download: # https://hpc.nih.gov/~mcgaugheyd/scEiaD/2021_11_11/study_level/SRP255195.seurat.Rdata load(\"~/Downloads/SRP255195.seurat.Rdata\") reference <- scEiaD  # these objects from the plae resource are named 'scEiaD' so we should rename it right away  #### filter down to cell types with at least 50 cells reference_meta <- reference@meta.data %>%     as_tibble(rownames = \"bc\") set.seed(2023.0721) celltypes_to_keep <- reference_meta %>%     group_by(CellType_predict) %>%     summarise(Count = n()) %>%     filter(Count >= 50, !is.na(CellType_predict)) %>%     pull(CellType_predict) reference_meta <- reference_meta %>%     filter(CellType_predict %in% celltypes_to_keep)  ######## cut down reference matrix to the well represented cell types ref_mat <- reference@assays$RNA@counts[, reference_meta$bc]  # mm_pca <- metamoRph::run_pca(feature_by_sample = ref_mat, meta = reference_meta, method = \"irlba\",     irlba_n = 50)"},{"path":"https://davemcg.github.io/metamoRph/articles/morph_scRNA_query_onto_reference.html","id":"diversion","dir":"Articles","previous_headings":"metamoRph::run_pca","what":"Diversion","title":"Transfer Labels from a Retina scRNA Reference onto a Query Dataset","text":"can put principal components (store mm_pca$PCA$x) UMAP make dangerous (distance little meaning!) useful visualization","code":"umap_reference <- uwot::umap(rbind(mm_pca$PCA$x[, 1:20]), ret_model = TRUE)   man_color <- pals::glasbey() names(man_color) <- celltypes_to_keep %>%     sort()   ref_viz <- umap_reference$embedding %>%     as_tibble(rownames = \"bc\") %>%     left_join(bind_rows(reference@meta.data %>%         as_tibble(rownames = \"bc\"), new_data@meta.data %>%         as_tibble(rownames = \"bc\"))) %>%     ggplot(aes(x = V1, y = V2, color = CellType_predict)) + geom_point(size = 0, alpha = 0.2) +     cowplot::theme_cowplot() + xlab(\"\") + ylab(\"\") + scale_color_manual(values = man_color) + ggrepel::geom_text_repel(data = . %>%     group_by(CellType_predict) %>%     summarise(V1 = mean(V1), V2 = mean(V2)), aes(label = CellType_predict), bg.color = \"white\") +     theme(legend.position = \"none\") + ggtitle(\"Reference: SRP255195\") ref_viz"},{"path":"https://davemcg.github.io/metamoRph/articles/morph_scRNA_query_onto_reference.html","id":"metamorphmetamorph","dir":"Articles","previous_headings":"","what":"metamoRph::metamoRph","title":"Transfer Labels from a Retina scRNA Reference onto a Query Dataset","text":"takes rotation matrix (prcomp’s $rotation) center/scale values calculated metamoRph::run_pca query (new) data input. query data features (genes) matched reference data, normalized manner reference data, multiplied rotation matrix. creates sample PCA space can directly compared PCA reference data.","code":"# https://hpc.nih.gov/~mcgaugheyd/scEiaD/2021_11_11/study_level/E-MTAB-7316.seurat.Rdata load(\"~/Downloads/E-MTAB-7316.seurat.Rdata\") new_data <- scEiaD pmat <- new_data@assays$RNA@counts proj <- metamoRph(new_counts = pmat, rotation = mm_pca$PCA$rotation[, 1:50], center_scale = mm_pca$center_scale) umap_new_data <- umap_transform(proj[, 1:20], umap_reference)   b <- umap_new_data %>%     as_tibble(rownames = \"bc\") %>%     left_join(bind_rows(reference@meta.data %>%         as_tibble(rownames = \"bc\"), new_data@meta.data %>%         as_tibble(rownames = \"bc\"))) %>%     filter(!is.na(CellType_predict), CellType_predict %in% celltypes_to_keep) %>%     ggplot(aes(x = V1, y = V2, color = CellType_predict)) + scattermore::geom_scattermore(pointsize = 2) +     cowplot::theme_cowplot() + xlab(\"\") + ylab(\"\") + scale_color_manual(values = man_color) + ggrepel::geom_label_repel(data = . %>%     group_by(CellType_predict) %>%     summarise(V1 = mean(V1), V2 = mean(V2)), aes(label = CellType_predict), alpha = 0.9) + theme(legend.position = \"none\") +     ggtitle(\"Morphed: EMTAB7316\")   cowplot::plot_grid(a, b, ncol = 2, align = \"v\", axis = \"r\")"},{"path":[]},{"path":"https://davemcg.github.io/metamoRph/articles/morph_scRNA_query_onto_reference.html","id":"metamorphmodel_build","dir":"Articles","previous_headings":"Label Transfer via ML","what":"metamoRph::model_build","title":"Transfer Labels from a Retina scRNA Reference onto a Query Dataset","text":"metamoRph also can perform label transfer (’s meta metamoRph) metamoRph::model_build. trains linear regression unique entry metadata field. seven cell types, train seven models tuned distinguish cell type remaining data. may wondering ’m using something simple linear regression. Model build support different models. Right now also can use random forest, xgboost, glm, svm. practice suggest linear regression (“lr”) reliably performs best fastest option. SVM pretty close second. also experimented several neural network based models perform substantially worse, chose make available.","code":""},{"path":"https://davemcg.github.io/metamoRph/articles/morph_scRNA_query_onto_reference.html","id":"metamorphmodel_apply","dir":"Articles","previous_headings":"Label Transfer via ML","what":"metamoRph::model_apply","title":"Transfer Labels from a Retina scRNA Reference onto a Query Dataset","text":"metamoRph::model_build returns list object model trained unique field (case cell types). used directly metamoRph::model_apply along query / new data’s output metamoRph::metamoRph. return predicted label along “max_score”, highest score returned individual models. Closer 0 indicates low confidence 1 indicates high confidence. already labels query data can also give metamoRph::model_apply known labels function output guessed labels. way can quickly check accuracy, case near 98%.","code":"ml <- metamoRph::model_build(mm_pca$PCA$x[, 1:50], mm_pca$meta %>%     pull(CellType_predict)) ma <- metamoRph::model_apply(ml, proj, new_data@meta.data$CellType_predict)  ma %>%     head() #> # A tibble: 6 × 6 #>   sample_id                   sample_label    predict         predict_second predict_stringent max_score #>   <chr>                       <chr>           <chr>           <chr>          <chr>                 <dbl> #> 1 AAACCTGAGAGGTAGA_ERS2852885 Rod             Rod             Bipolar Cell   Unknown               0.451 #> 2 AAACCTGAGCCATCGC_ERS2852885 Rod             Rod             Bipolar Cell   Rod                   0.517 #> 3 AAACCTGCAGACGTAG_ERS2852885 Rod             Rod             Muller Glia    Unknown               0.464 #> 4 AAACCTGGTGCTGTAT_ERS2852885 Rod             Rod             Bipolar Cell   Unknown               0.462 #> 5 AAACCTGTCAAGATCC_ERS2852885 Amacrine Cell   Amacrine Cell   Pericyte       Amacrine Cell         1.53  #> 6 AAACCTGTCTTGAGAC_ERS2852885 Horizontal Cell Horizontal Cell Amacrine Cell  Horizontal Cell       0.928 # overall accuracy ma %>%     filter(sample_label == predict) %>%     nrow()/ma %>%     filter(!is.na(sample_label)) %>%     nrow() #> [1] 0.984965"},{"path":"https://davemcg.github.io/metamoRph/articles/real_data_testing.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Metadata Label Transfer on Real Data","text":"take data EiaD resource, cut dozen cornea, retina, RPE samples well first thousand variable genes (calculated variance).","code":""},{"path":"https://davemcg.github.io/metamoRph/articles/real_data_testing.html","id":"load-libraries","dir":"Articles","previous_headings":"","what":"Load libraries","title":"Metadata Label Transfer on Real Data","text":"","code":"library(projectR) library(metamoRph) library(dplyr) library(ggplot2)"},{"path":"https://davemcg.github.io/metamoRph/articles/real_data_testing.html","id":"import-eiad-data","dir":"Articles","previous_headings":"","what":"Import EiaD data","title":"Metadata Label Transfer on Real Data","text":"ocular subset full resource (full data can found eyeIntegration.nei.nih.gov)","code":"feature_by_sample <- data.table::fread(   system.file('test_data/EiaD__eye_samples_counts.csv.gz', package = 'metamoRph') ) genes <- feature_by_sample$Gene feature_by_sample <- feature_by_sample[,-1] %>% as.matrix() row.names(feature_by_sample) <- genes meta_ref <- data.table::fread(   system.file('test_data/EiaD__eye_samples_metaRef.csv.gz', package = 'metamoRph') ) meta_project <- data.table::fread(    system.file('test_data/EiaD__eye_samples_metaProject.csv.gz', package = 'metamoRph') )"},{"path":"https://davemcg.github.io/metamoRph/articles/real_data_testing.html","id":"projectr","dir":"Articles","previous_headings":"","what":"projectR","title":"Metadata Label Transfer on Real Data","text":"projectR apply prcomp row (gene) scaling, new data (red circle) ends center PCA plot. Scaling new data alone also results variation samples exaggerated.","code":"ref_matrix <- feature_by_sample[,meta_ref %>% pull(sample_accession)] Pvars <- sparseMatrixStats::rowVars(log1p(ref_matrix)) select <- order(Pvars, decreasing = TRUE)[seq_len(min(1000,                                                       length(Pvars)))]  pr_run <- prcomp(log1p(t(ref_matrix[select,])),                  scale = TRUE,                  center = TRUE)  new_mat_for_projection <- feature_by_sample[select,                                             meta_project %>% pull(sample_accession)]  pr_proj <- projectR(data = log1p(as.matrix(new_mat_for_projection)),                     loadings = pr_run,                     dataNames = row.names(new_mat_for_projection)) #> [1] \"1000 row names matched between data and loadings\" #> [1] \"Updated dimension of data: 1000 12\"  data_plot <- bind_rows(cbind(t(pr_proj), meta_project %>%                                mutate(Tissue = paste0(Tissue, \" Projected\"), Data = 'Projection')),                        cbind(pr_run$x, meta_ref)) data_plot %>%   mutate(Tissue = case_when(Cohort == 'Body' ~ 'Body', TRUE ~ Tissue)) %>%   ggplot(aes(x=PC1,y=PC2, color = Tissue)) + geom_point() +   ggforce::geom_mark_ellipse(data = data_plot %>% filter(Data == 'Projection'), color = 'red', linewidth = 2) +   scale_color_manual(values = pals::alphabet(n=12)%>% unname()) +   ggforce::geom_mark_ellipse() +   cowplot::theme_cowplot()"},{"path":"https://davemcg.github.io/metamoRph/articles/real_data_testing.html","id":"metamorph","dir":"Articles","previous_headings":"","what":"metamoRph","title":"Metadata Label Transfer on Real Data","text":"metamoRph’s two steps (run_pca metamoRph) gets new data proper scale projection work properly.","code":"pca_output <- run_pca(feature_by_sample = ref_matrix[select,],                       meta = meta_ref,                       hvg_selection = 'classic',                       sample_scale = 'none')  # project data from the pca rownames(new_mat_for_projection) <- gsub(' \\\\(.*','',rownames(new_mat_for_projection)) projected_data <- metamoRph(new_mat_for_projection,                             pca_output$PCA$rotation,                             center_scale = pca_output$center_scale,                             sample_scale =  'none') data_plot <- bind_rows(cbind(projected_data, meta_project %>%                                mutate(Tissue = paste0(Tissue, \" Projected\"),                                       Data = 'Projection')),                        cbind(pca_output$PCA$x, meta_ref) %>%                          mutate(Data = 'Original')) data_plot %>%   mutate(Tissue = case_when(Cohort == 'Body' ~ 'Body', TRUE ~ Tissue)) %>%   ggplot(aes(x=PC1,y=PC2,color = Tissue)) +   geom_point() +   scale_color_manual(values = pals::alphabet(n=12) %>% unname()) +   ggforce::geom_mark_ellipse(data = data_plot %>% filter(Data == 'Projection'), color = 'red', linewidth = 2) +   ggforce::geom_mark_ellipse() +      cowplot::theme_cowplot()"},{"path":"https://davemcg.github.io/metamoRph/articles/real_data_testing.html","id":"metamorph-with-cpm-scaling-and-scran-hvg-selection","dir":"Articles","previous_headings":"","what":"metamoRph with cpm scaling and scran HVG selection","title":"Metadata Label Transfer on Real Data","text":"CPM scran steps modestly improves PC1/PC2 distinction tissue types well pulling outliers back towards matching tissue type.","code":"pca_output <- run_pca(ref_matrix[select,],                       meta_ref,                       hvg_selection = 'scran',                       sample_scale = 'zscale')  # project data from the pca projected_data <- metamoRph(new_mat_for_projection,                             pca_output$PCA$rotation,                             center_scale = pca_output$center_scale,                             sample_scale = 'zscale')  data_plot <- bind_rows(cbind(projected_data, meta_project %>%                                mutate(Tissue = paste0(Tissue, \" Projected\"),                                       Data = 'Projection')),                        cbind(pca_output$PCA$x, meta_ref) %>%                          mutate(Data = 'Original')) data_plot %>%   mutate(Tissue = case_when(Cohort == 'Body' ~ 'Body', TRUE ~ Tissue)) %>%   ggplot(aes(x=PC1,y=PC2,color = Tissue)) +   geom_point() +   scale_color_manual(values = pals::alphabet(n=12) %>% unname()) +   ggforce::geom_mark_ellipse(data = data_plot %>% filter(Data == 'Projection'), color = 'red', linewidth = 2) +     ggforce::geom_mark_ellipse() +   cowplot::theme_cowplot()"},{"path":"https://davemcg.github.io/metamoRph/articles/real_data_testing.html","id":"label-transfer","dir":"Articles","previous_headings":"","what":"Label Transfer","title":"Metadata Label Transfer on Real Data","text":"Finally demonstrate two step process transferring labels input data onto projected data. First run model_build original pca_output eigenvalue matrix ($x). also provide label data interest transfer (tissue). Behind scenes lm model built unique label (case tissue) tissues using first 10 PCs. output list models (one tissue type). can use list models model_apply well projected data metamoRph. provide (optional) true labels projected data. tibble returned gives original label (provided) sample_label field well predicted label (predict) field. max_score confidence model prediction. Closer 0 low confidence closer 1 high confidence.","code":"trained_model <- model_build(pca_output$PCA$x,                              pca_output$meta$Tissue,                              model = 'lm', num_PCs = 10, verbose = FALSE,                              BPPARAM = MulticoreParam(10))  label_guesses <- model_apply(trained_model,                              projected_data,                              meta_project$Tissue )  label_guesses #> # A tibble: 12 × 6 #>    sample_id  sample_label predict predict_second    predict_stringent max_score #>    <chr>      <chr>        <chr>   <chr>             <chr>                 <dbl> #>  1 SRS8476047 Retina       Retina  Trabecular Meshw… Retina                0.925 #>  2 SRS8476048 Retina       Retina  Trabecular Meshw… Retina                0.994 #>  3 SRS8476049 Retina       Retina  Trabecular Meshw… Retina                1.00  #>  4 SRS8476039 Retina       Retina  Trabecular Meshw… Retina                0.956 #>  5 SRS8476038 Retina       Retina  Trabecular Meshw… Retina                0.974 #>  6 SRS8476040 Retina       Retina  Trabecular Meshw… Retina                0.952 #>  7 SRS8476041 Retina       Retina  Trabecular Meshw… Retina                0.974 #>  8 SRS8476042 Retina       Retina  Trabecular Meshw… Retina                0.959 #>  9 SRS8476043 Retina       Retina  Trabecular Meshw… Retina                0.975 #> 10 SRS8476044 Retina       Retina  Trabecular Meshw… Retina                0.944 #> 11 SRS8476045 Retina       Retina  Trabecular Meshw… Retina                0.985 #> 12 SRS8476046 Retina       Retina  Conjunctiva       Retina                1.01"},{"path":"https://davemcg.github.io/metamoRph/articles/seurat__integration_mapping.html","id":"introduction-to-single-cell-reference-mapping","dir":"Articles","previous_headings":"","what":"Introduction to single-cell reference mapping","title":"Mapping and annotating query datasets","text":"vignette, first build integrated reference demonstrate leverage reference annotate new query datasets. Generating integrated reference follows workflow described detail integration introduction vignette. generated, reference can used analyze additional query datasets tasks like cell type label transfer projecting query cells onto reference UMAPs. Notably, require correction underlying raw query data can therefore efficient strategy high quality reference available.","code":""},{"path":"https://davemcg.github.io/metamoRph/articles/seurat__integration_mapping.html","id":"dataset-preprocessing","dir":"Articles","previous_headings":"","what":"Dataset preprocessing","title":"Mapping and annotating query datasets","text":"purposes example, ’ve chosen human pancreatic islet cell datasets produced across four technologies, CelSeq (GSE81076) CelSeq2 (GSE85241), Fluidigm C1 (GSE86469), SMART-Seq2 (E-MTAB-5061). convenience, distribute dataset SeuratData package. metadata contains technology (tech column) cell type annotations (celltype column) cell four datasets. construct reference, identify ‘anchors’ individual datasets. First, split combined object list, dataset element (necessary data bundled together easy distribution). Prior finding anchors, perform standard preprocessing (log-normalization), identify variable features individually . Note Seurat implements improved method variable feature selection based variance stabilizing transformation (\"vst\")","code":"library(Seurat) library(SeuratData) InstallData(\"panc8\") data(\"panc8\") pancreas.list <- SplitObject(panc8, split.by = \"tech\") pancreas.list <- pancreas.list[c(\"celseq\", \"celseq2\", \"fluidigmc1\", \"smartseq2\")] for (i in 1:length(pancreas.list)) {     pancreas.list[[i]] <- NormalizeData(pancreas.list[[i]], verbose = FALSE)     pancreas.list[[i]] <- FindVariableFeatures(pancreas.list[[i]], selection.method = \"vst\", nfeatures = 2000,         verbose = FALSE) }"},{"path":"https://davemcg.github.io/metamoRph/articles/seurat__integration_mapping.html","id":"integration-of-3-pancreatic-islet-cell-datasets","dir":"Articles","previous_headings":"","what":"Integration of 3 pancreatic islet cell datasets","title":"Mapping and annotating query datasets","text":"Next, identify anchors using FindIntegrationAnchors() function, takes list Seurat objects input. , integrate three objects reference (use fourth later vignette query dataset demonstrate mapping). use default parameters identifying anchors, including ‘dimensionality’ dataset (30; feel free try varying parameter broad range, example 10 50). pass anchors IntegrateData() function, returns Seurat object. returned object contain new Assay, holds integrated (‘batch-corrected’) expression matrix cells, enabling jointly analyzed. running IntegrateData(), Seurat object contain new Assay integrated expression matrix. Note original (uncorrected values) still stored object “RNA” assay, can switch back forth. can use new integrated matrix downstream analysis visualization. scale integrated data, run PCA, visualize results UMAP. integrated datasets cluster cell type, instead technology.","code":"reference.list <- pancreas.list[c(\"celseq\", \"celseq2\", \"smartseq2\")] pancreas.anchors <- FindIntegrationAnchors(object.list = reference.list, dims = 1:30) pancreas.integrated <- IntegrateData(anchorset = pancreas.anchors, dims = 1:30) library(ggplot2) library(cowplot) library(patchwork) # switch to integrated assay. The variable features of this assay are automatically set during # IntegrateData DefaultAssay(pancreas.integrated) <- \"integrated\" # Run the standard workflow for visualization and clustering pancreas.integrated <- ScaleData(pancreas.integrated, verbose = FALSE) pancreas.integrated <- RunPCA(pancreas.integrated, npcs = 30, verbose = FALSE) pancreas.integrated <- RunUMAP(pancreas.integrated, reduction = \"pca\", dims = 1:30, verbose = FALSE) p1 <- DimPlot(pancreas.integrated, reduction = \"umap\", group.by = \"tech\") p2 <- DimPlot(pancreas.integrated, reduction = \"umap\", group.by = \"celltype\", label = TRUE, repel = TRUE) +     NoLegend() p1 + p2"},{"path":"https://davemcg.github.io/metamoRph/articles/seurat__integration_mapping.html","id":"cell-type-classification-using-an-integrated-reference","dir":"Articles","previous_headings":"","what":"Cell type classification using an integrated reference","title":"Mapping and annotating query datasets","text":"Seurat also supports projection reference data (meta data) onto query object. many methods conserved (procedures begin identifying anchors), two important distinctions data transfer integration: data transfer, Seurat correct modify query expression data. data transfer, Seurat option (set default) project PCA structure reference onto query, instead learning joint structure CCA. generally suggest using option projecting data scRNA-seq datasets. finding anchors, use TransferData() function classify query cells based reference data (vector reference cell type labels). TransferData() returns matrix predicted IDs prediction scores, can add query metadata. original label annotations full integrated analysis, can evaluate well predicted cell type annotations match full reference. example, find high agreement cell type classification, 96% cells labeled correctly. verify , can examine canonical cell type markers specific pancreatic islet cell populations. Note even though cell types represented one two cells (e.g. epsilon cells), still able classify correctly.","code":"pancreas.query <- pancreas.list[[\"fluidigmc1\"]] pancreas.anchors <- FindTransferAnchors(reference = pancreas.integrated, query = pancreas.query,     dims = 1:30, reference.reduction = \"pca\") predictions <- TransferData(anchorset = pancreas.anchors, refdata = pancreas.integrated$celltype,     dims = 1:30) pancreas.query <- AddMetaData(pancreas.query, metadata = predictions) pancreas.query$prediction.match <- pancreas.query$predicted.id == pancreas.query$celltype table(pancreas.query$prediction.match) ##  ## FALSE  TRUE  ##    21   617 table(pancreas.query$predicted.id) ##  ##             acinar activated_stellate              alpha               beta  ##                 22                 17                253                256  ##              delta             ductal        endothelial              gamma  ##                 22                 30                 12                 18  ##         macrophage               mast            schwann  ##                  1                  2                  5 VlnPlot(pancreas.query, c(\"REG1A\", \"PPY\", \"SST\", \"GHRL\", \"VWF\", \"SOX10\"), group.by = \"predicted.id\")"},{"path":"https://davemcg.github.io/metamoRph/articles/seurat__integration_mapping.html","id":"unimodal-umap-projection","dir":"Articles","previous_headings":"","what":"Unimodal UMAP Projection","title":"Mapping and annotating query datasets","text":"Seurat v4, also enable projection query onto reference UMAP structure. can achieved computing reference UMAP model calling MapQuery() instead TransferData(). MapQuery() wrapper around three functions: TransferData(), IntegrateEmbeddings(), ProjectUMAP(). TransferData() used transfer cell type labels impute ADT values; IntegrateEmbeddings() used integrate reference query correcting query’s projected low-dimensional embeddings; finally ProjectUMAP() used project query data onto UMAP structure reference. equivalent code intermediate functions : can now visualize query cells alongside reference.","code":"pancreas.integrated <- RunUMAP(pancreas.integrated, dims = 1:30, reduction = \"pca\", return.model = TRUE) pancreas.query <- MapQuery(anchorset = pancreas.anchors, reference = pancreas.integrated, query = pancreas.query,     refdata = list(celltype = \"celltype\"), reference.reduction = \"pca\", reduction.model = \"umap\") pancreas.query <- TransferData(anchorset = pancreas.anchors, reference = pancreas.integrated, query = pancreas.query,     refdata = list(celltype = \"celltype\")) pancreas.query <- IntegrateEmbeddings(anchorset = pancreas.anchors, reference = pancreas.integrated,     query = pancreas.query, new.reduction.name = \"ref.pca\") pancreas.query <- ProjectUMAP(query = pancreas.query, query.reduction = \"ref.pca\", reference = pancreas.integrated,     reference.reduction = \"pca\", reduction.model = \"umap\") p1 <- DimPlot(pancreas.integrated, reduction = \"umap\", group.by = \"celltype\", label = TRUE, label.size = 3,     repel = TRUE) + NoLegend() + ggtitle(\"Reference annotations\") p2 <- DimPlot(pancreas.query, reduction = \"ref.umap\", group.by = \"predicted.celltype\", label = TRUE,     label.size = 3, repel = TRUE) + NoLegend() + ggtitle(\"Query transferred labels\") p1 + p2 sessionInfo() ## R version 4.3.0 (2023-04-21) ## Platform: aarch64-apple-darwin20 (64-bit) ## Running under: macOS Ventura 13.4.1 ##  ## Matrix products: default ## BLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib  ## LAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0 ##  ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ##  ## time zone: America/New_York ## tzcode source: internal ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] patchwork_1.1.2        cowplot_1.1.1          ggplot2_3.4.2          ## [4] panc8.SeuratData_3.0.2 SeuratData_0.2.2       SeuratObject_4.1.3     ## [7] Seurat_4.3.0.1         ##  ## loaded via a namespace (and not attached): ##   [1] RColorBrewer_1.1-3     rstudioapi_0.14        jsonlite_1.8.4         ##   [4] magrittr_2.0.3         ggbeeswarm_0.7.2       spatstat.utils_3.0-3   ##   [7] farver_2.1.1           rmarkdown_2.21         fs_1.6.2               ##  [10] ragg_1.2.5             vctrs_0.6.2            ROCR_1.0-11            ##  [13] memoise_2.0.1          spatstat.explore_3.2-1 htmltools_0.5.5        ##  [16] sass_0.4.6             sctransform_0.3.5      parallelly_1.36.0      ##  [19] KernSmooth_2.23-21     bslib_0.5.0            htmlwidgets_1.6.2      ##  [22] desc_1.4.2             ica_1.0-3              plyr_1.8.8             ##  [25] plotly_4.10.1          zoo_1.8-12             cachem_1.0.8           ##  [28] igraph_1.4.3           mime_0.12              lifecycle_1.0.3        ##  [31] pkgconfig_2.0.3        Matrix_1.5-4.1         R6_2.5.1               ##  [34] fastmap_1.1.1          fitdistrplus_1.1-11    future_1.32.0          ##  [37] shiny_1.7.4            digest_0.6.31          colorspace_2.1-0       ##  [40] rprojroot_2.0.3        tensor_1.5             irlba_2.3.5.1          ##  [43] textshaping_0.3.6      labeling_0.4.2         progressr_0.13.0       ##  [46] fansi_1.0.4            spatstat.sparse_3.0-2  httr_1.4.6             ##  [49] polyclip_1.10-4        abind_1.4-5            compiler_4.3.0         ##  [52] withr_2.5.0            highr_0.10             MASS_7.3-60            ##  [55] rappdirs_0.3.3         tools_4.3.0            vipor_0.4.5            ##  [58] lmtest_0.9-40          beeswarm_0.4.0         httpuv_1.6.11          ##  [61] future.apply_1.11.0    goftest_1.2-3          glue_1.6.2             ##  [64] nlme_3.1-162           promises_1.2.0.1       grid_4.3.0             ##  [67] Rtsne_0.16             cluster_2.1.4          reshape2_1.4.4         ##  [70] generics_0.1.3         gtable_0.3.3           spatstat.data_3.0-1    ##  [73] tidyr_1.3.0            data.table_1.14.8      sp_2.0-0               ##  [76] utf8_1.2.3             spatstat.geom_3.2-2    RcppAnnoy_0.0.20       ##  [79] ggrepel_0.9.3          RANN_2.6.1             pillar_1.9.0           ##  [82] stringr_1.5.0          later_1.3.1            splines_4.3.0          ##  [85] dplyr_1.1.2            lattice_0.21-8         survival_3.5-5         ##  [88] deldir_1.0-9           tidyselect_1.2.0       miniUI_0.1.1.1         ##  [91] pbapply_1.7-2          knitr_1.43             gridExtra_2.3          ##  [94] scattermore_1.1        xfun_0.39              matrixStats_0.63.0     ##  [97] stringi_1.7.12         lazyeval_0.2.2         yaml_2.3.7             ## [100] evaluate_0.21          codetools_0.2-19       tibble_3.2.1           ## [103] cli_3.6.1              uwot_0.1.14            xtable_1.8-4           ## [106] reticulate_1.28        systemfonts_1.0.4      munsell_0.5.0          ## [109] jquerylib_0.1.4        Rcpp_1.0.10            globals_0.16.2         ## [112] spatstat.random_3.1-5  png_0.1-8              ggrastr_1.0.1          ## [115] parallel_4.3.0         ellipsis_0.3.2         pkgdown_2.0.7          ## [118] listenv_0.9.0          viridisLite_0.4.2      scales_1.2.1           ## [121] ggridges_0.5.4         leiden_0.4.3           purrr_1.0.1            ## [124] crayon_1.5.2           rlang_1.1.1            formatR_1.14"},{"path":"https://davemcg.github.io/metamoRph/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"David McGaughey. Author, maintainer.","code":""},{"path":"https://davemcg.github.io/metamoRph/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"McGaughey D (2023). metamoRph: Metadata projection via data morphing matrix factorization multiplication. R package version 0.2.0, https://davemcg.github.io/metamoRph/.","code":"@Manual{,   title = {metamoRph: Metadata projection via data morphing with matrix factorization multiplication},   author = {David McGaughey},   year = {2023},   note = {R package version 0.2.0},   url = {https://davemcg.github.io/metamoRph/}, }"},{"path":"https://davemcg.github.io/metamoRph/index.html","id":"metamorph","dir":"","previous_headings":"","what":"Metadata projection via data morphing with matrix factorization multiplication","title":"Metadata projection via data morphing with matrix factorization multiplication","text":"framework projecting query (new) data onto reference PCA space. easiest two step process user runs run_pca function (wraps prcomp provides sensible defaults enhanced outputs. run_pca user can use metamoRph normalize query (new) data manner reference data project onto existing reference PCA. also provides two functions, model_build model_apply quickly transfer metadata onto new data using shared PCA space reference query.","code":""},{"path":"https://davemcg.github.io/metamoRph/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick Start","title":"Metadata projection via data morphing with matrix factorization multiplication","text":"","code":"remotes::install_github(\"davemcg/metamoRph\") library(metamoRph) library(dplyr) library(ggplot2) library(dplyr) library(ggplot2)  genes <- c('RHO','RPE65','ABCA4','PMEL', 'KRT5') samples <- c('Retina1','Retina2','RPE1','RPE2','Cornea1')  faux_mat <- cbind(c(560,650,5,6,0), # rho                   c(42,32, 1103,1201,2), #rpe65                   c(810,903,202,205,45),  #abca4                   c(100,105,2004,1980,101),# pmel                   c(3,32,101,202,1567)) |> data.frame()# krt5 colnames(faux_mat) <- genes row.names(faux_mat) <- samples  new_data <- cbind(c(5,6,3), # rho                   c(32,23,54), #rpe65                   c(65,22,10),  #abca4                   c(122,101,57),# pmel                   c(2567,1755,2218)) * 100 # krt5 colnames(new_data) <- genes row.names(new_data) <- c(\"Cornea2\",\"Cornea3\",\"Cornea4\")  mm_pca <- run_pca(t(faux_mat), meta = samples |> data.frame()) projected_pca <- metamoRph(t(new_data),                                 mm_pca$PCA$rotation,                                 center_scale = mm_pca$center_scale)  # example plot # bind_rows(as_tibble(mm_pca$PCA$x, rownames = 'samples'), #       as_tibble(projected_pca, rownames = 'Cornea')) |> #   mutate(samples = gsub('\\\\d','',samples)) |> #   ggplot(aes(x=PC1,y=PC2,color=samples)) +  #   geom_point() + #   cowplot::theme_cowplot()"},{"path":"https://davemcg.github.io/metamoRph/index.html","id":"label-projection","dir":"","previous_headings":"","what":"Label projection","title":"Metadata projection via data morphing with matrix factorization multiplication","text":"","code":"# continue from code chunk above ## WARNING: Use many more num_PCs (20+) for \"real\" genomic data trained_model <- model_build(mm_pca$PCA$x,                              gsub('\\\\d+','', mm_pca$meta$samples), #remove trailing digit                               model = 'lm', num_PCs = 2)  label_guesses <- model_apply(trained_model,                              projected_pca,                              c(\"Cornea\",\"Cornea\",\"Cornea\") )  # label_guesses"},{"path":"https://davemcg.github.io/metamoRph/index.html","id":"existing-prcomp-object-projection-example-pseudocode-ish","dir":"","previous_headings":"","what":"Existing prcomp object projection example (pseudocode-ish)","title":"Metadata projection via data morphing with matrix factorization multiplication","text":"also possible use pre-existing prcomp object metamoRph, skipping run_pca step. ensure sample scale new_data manner used prcomp run (use log2 - replace whatever scaling done. Maybe none?). Note turned cpm log1p scaling metamoRph function normaliztion = FALSE.","code":"library(metamoRph) projected_pca <- metamoRph(t(log2(new_data)),                                 your_prcomp_object$PCA$rotation,                                 center_scale = extract_prcomp_scaling(your_prcomp_object),                                normalization = FALSE)"},{"path":"https://davemcg.github.io/metamoRph/index.html","id":"some-related-tools","dir":"","previous_headings":"","what":"Some Related Tools","title":"Metadata projection via data morphing with matrix factorization multiplication","text":"scRNA/Seurat based tool uses similar approach project data (essentialy multiplying new rotation matrix) big kahuna . scRNA analysis playground. Can transfer data onto PCA NMF least PCA provide guardrails properly scaling query data","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/extract_prcomp_scaling.html","id":null,"dir":"Reference","previous_headings":"","what":"extract_prcomp_scaling — extract_prcomp_scaling","title":"extract_prcomp_scaling — extract_prcomp_scaling","text":"function takes prcomp object returns center scale vectors list can used metamoRph::metamoRph.","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/extract_prcomp_scaling.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"extract_prcomp_scaling — extract_prcomp_scaling","text":"","code":"extract_prcomp_scaling(prcomp_object)"},{"path":"https://davemcg.github.io/metamoRph/reference/extract_prcomp_scaling.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"extract_prcomp_scaling — extract_prcomp_scaling","text":"prcomp_object precomputed prcomp object","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/extract_prcomp_scaling.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"extract_prcomp_scaling — extract_prcomp_scaling","text":"list object containing prcomp \"center\" \"scale\" values use metamoRph function","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/extract_prcomp_scaling.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"extract_prcomp_scaling — extract_prcomp_scaling","text":"function used metamoRph::run_pca","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/metamoRph.html","id":null,"dir":"Reference","previous_headings":"","what":"metamoRph — metamoRph","title":"metamoRph — metamoRph","text":"Takes count matrix (genes (features) rows samples columns) well named vector eigenvalues (see run_pca()) pulls gene (feature) information rotation vector cuts new_counts matrix match rotation vector gene (feature) names. genes (features) missing input new_counts matrix replaced zeros.","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/metamoRph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"metamoRph — metamoRph","text":"","code":"metamoRph(   new_counts,   rotation,   center_scale = NULL,   normalization = TRUE,   sample_scale = \"cpm\",   feature_scale = FALSE,   log1p = TRUE )"},{"path":"https://davemcg.github.io/metamoRph/reference/metamoRph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"metamoRph — metamoRph","text":"new_counts raw gene count matrix (genes rows samples columns) rotation matrix row names genes col names principal components. used metamoRph::run_pca() output$PCA$rotation slot. center_scale list object $center slot center values $scale slot scale value \"scale\" function. give value , feature/gene scaling HAPPEN. normalization Default TRUE, set FALSE override sample_scale log1p sample scaling sample_scale Options include cpm, seurat, zscale,  none. MUST match normalization used data run_pca (rotation came ). feature_scale Default FALSE, TRUE apply feature (gene) scaling input (query) data (center_scale left empty). DANGEROUS likely put query data different scale reference data. Use deliberate intent. log1p Default TRUE. , must match normalization used data run_pca (rotation came ).","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/metamoRph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"metamoRph — metamoRph","text":"matrix transformated eigenvalue matrix equivalent original rotation matrix's eigenvalue/pattern matrix ($x slot output prcomp)","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/metamoRph.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"metamoRph — metamoRph","text":"function scale new_counts matrix manner run_pca() matrix multiply rotation vector. output equivalent prcomp \"$x\" matrix.","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/model_apply.html","id":null,"dir":"Reference","previous_headings":"","what":"model_apply — model_apply","title":"model_apply — model_apply","text":"function uses output model_build()","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/model_apply.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"model_apply — model_apply","text":"","code":"model_apply(   list_of_models,   experiment_data,   experiment_labels = \"\",   return_predictions = FALSE )"},{"path":"https://davemcg.github.io/metamoRph/reference/model_apply.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"model_apply — model_apply","text":"list_of_models list object containing one model per sample type (e.g. photoreceptors vs -photoreceptors) experiment_data Projected data metamoRph() experiment_labels Optional labels users experiment_data return_predictions default predicted labels returned. set TRUE, entire matrix probabilities sample (label type) returned.","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/model_apply.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"model_apply — model_apply","text":"default, table predicted labels data, return_predictions set TRUE matrix probabilities sample type returned (rows samples columns sample type probability)","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/model_build.html","id":null,"dir":"Reference","previous_headings":"","what":"model_build — model_build","title":"model_build — model_build","text":"function uses training_data training_labels build lm based model label type can used model_apply(). training_data intended sample x PC (principal component) row x column matrix. $x output base R prcomp. provide precomputed prcomp PCA outputs plae.nei.nih.gov resource adult human eye, adult mouse eye, fetal human eye, fetal mouse eye ( see vignette(\"pca_download\", package = \"metamoRph\"))","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/model_build.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"model_build — model_build","text":"","code":"model_build(   training_data,   training_labels,   num_PCs = 50,   BPPARAM = BiocParallel::SerialParam(),   model = \"lm\",   verbose = TRUE )"},{"path":"https://davemcg.github.io/metamoRph/reference/model_build.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"model_build — model_build","text":"training_data sample (row) principal component (column) matrix training_labels vector row-matched labels (e.g. cell types) sample. num_PCs number principal components use training_data. Defaults first (top) 50. BPPARAM BiocParallel class model Default lm. also support xgboost, glm, rf, svm. experience find lm svm best performers. verbose Print training status label type","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/model_build.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"model_build — model_build","text":"list models individual label type","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/normalize_data.html","id":null,"dir":"Reference","previous_headings":"","what":"normalize_data — normalize_data","title":"normalize_data — normalize_data","text":"Applies sample level normalization high variable feature (gene) selection. cpm scaling selected, scuttle::calculateCPM applied log1p (TRUE). zscale apply log1p first (TRUE).","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/normalize_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"normalize_data — normalize_data","text":"","code":"normalize_data(feature_by_sample, sample_scale = \"cpm\", log1p = TRUE)"},{"path":"https://davemcg.github.io/metamoRph/reference/normalize_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"normalize_data — normalize_data","text":"feature_by_sample features (row) sample (column) matrix sample_scale Options include cpm, seurat, zscale,  none log1p Default TRUE","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/normalize_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"normalize_data — normalize_data","text":"list object containing prcomp \"center\" \"scale\" values use metamoRph function","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/normalize_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"normalize_data — normalize_data","text":"function used metamoRph::metamoRph metamoRph::run_pca","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/run_pca.html","id":null,"dir":"Reference","previous_headings":"","what":"run_pca — run_pca","title":"run_pca — run_pca","text":"function takes count matrix (genes (features) rows samples columns) sample level metadata returns list object R::prcomp calculated object, metadata, percent variance explained principal component, genes (features) chosen PCA","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/run_pca.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"run_pca — run_pca","text":"","code":"run_pca(   feature_by_sample,   meta,   method = \"prcomp\",   ntop = 1000,   hvg_selection = \"scran\",   hvg_force = NULL,   feature_scale = TRUE,   feature_center = TRUE,   normalization = TRUE,   sample_scale = \"cpm\",   log1p = TRUE,   remove_regex = \"^MT|^RPS|^RPL\",   irlba_n = 50 )"},{"path":"https://davemcg.github.io/metamoRph/reference/run_pca.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"run_pca — run_pca","text":"feature_by_sample Raw feature (gene) count matrix (genes/features rows samples columns). meta Metadata samples. rows must match columns feature_by_sample. method Defaults prcomp, use irlba large matrices speed improvement ntop Number highly variable genes/features use prcomp PCA. Defaults 1000. hvg_selection Either \"classic\" \"scran\" select \"ntop\" features. \"classic\" simply use top n features variance, \"scran\" use scran package's strategy scaling variance expression (highly expressed features/genes) also higher variance thus may less useful sample distinction. hvg_force Optional vector features / genes must stats::promp input feature_scale Default TRUE, means features (genes) scaled R::scale function. feature_center Default TRUE, means features (genes) centered normalization Default TRUE, set FALSE override sample_scale log1p sample scaling sample_scale Default cpm; performs cpm scaling samples scuttle::calculateCPM() function. log1p Default TRUE; applies log1p scaling input count matrix. remove_regex Default regex pattern '^MT|^RPS|^RPL'. Set '' skip. irlba_n Default 50. used irlba - return many principal components.","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/run_pca.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"run_pca — run_pca","text":"named list object prcomp output returned $PCA slot, given metadata $meta slot, percent variance PC $percentVar slot, list object containing scaled data's \"center\" \"scale\" values use metamoRph function, used parameters $params slot.\\","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/select_HVG.html","id":null,"dir":"Reference","previous_headings":"","what":"select_HVG — select_HVG","title":"select_HVG — select_HVG","text":"Takes input normalized matrix (see metamoRph::normalize_data). Returns ntop high variable genes either \"classic\" method orders features variance \"scran\" uses scran package's strategy scaling variance value (larger features/genes) also higher variance thus may less useful sample distinction.","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/select_HVG.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"select_HVG — select_HVG","text":"","code":"select_HVG(   feature_by_sample,   ntop = 1000,   hvg_selection = \"scran\",   remove_regex = \"^MT|^RPS|^RPL\",   hvg_force = NULL )"},{"path":"https://davemcg.github.io/metamoRph/reference/select_HVG.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"select_HVG — select_HVG","text":"feature_by_sample Raw feature (gene) count matrix (genes/features rows samples columns). ntop Number highly variable genes/features use prcomp PCA. Defaults 1000. hvg_selection Either \"classic\" \"scran\" select \"ntop\" features. \"classic\" simply use top n features variance, \"scran\" use scran package's strategy scaling variance expression (highly expressed features/genes) also higher variance thus may less useful sample distinction. remove_regex Default regex pattern '^MT|^RPS|^RPL'. Set '' skip. hvg_force Optional vector features / genes must stats::promp","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/select_HVG.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"select_HVG — select_HVG","text":"character vector ntop features","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/select_HVG.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"select_HVG — select_HVG","text":"function used metamoRph::run_pca","code":""},{"path":"https://davemcg.github.io/metamoRph/news/index.html","id":"metamorph-020","dir":"Changelog","previous_headings":"","what":"metamoRph 0.2.0","title":"metamoRph 0.2.0","text":"two new functions, select_HVG normalize_data pulled partially duplicated code run_pca metamoRph ease future normalization additions modularize code-base irlba added prcomp alternative speed large single cell dataset dimensionality reduction add new sample normalization method: Seurat’s “LogNormalize” two new scRNA-seq vignettes added","code":""},{"path":"https://davemcg.github.io/metamoRph/news/index.html","id":"metamorph-013","dir":"Changelog","previous_headings":"","what":"metamoRph 0.1.3","title":"metamoRph 0.1.3","text":"run_pca metamoRph now support sparseMatrix","code":""},{"path":"https://davemcg.github.io/metamoRph/news/index.html","id":"metamorph-012","dir":"Changelog","previous_headings":"","what":"metamoRph 0.1.2","title":"metamoRph 0.1.2","text":"add tests testthat tweak Metadata Label Transfer Real Data vignette plots mark tissue grouping ggforce::geom_mark_ellipse","code":""},{"path":"https://davemcg.github.io/metamoRph/news/index.html","id":"metamorph-011","dir":"Changelog","previous_headings":"","what":"metamoRph 0.1.1","title":"metamoRph 0.1.1","text":"improve vignettes add extract_prcomp_scaling()function yank center/scale information prcomp object","code":""},{"path":"https://davemcg.github.io/metamoRph/news/index.html","id":"metamorph-010","dir":"Changelog","previous_headings":"","what":"metamoRph 0.1.0","title":"metamoRph 0.1.0","text":"release","code":""}]
