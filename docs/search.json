[{"path":"https://davemcg.github.io/metamoRph/articles/So_many_ways_to_screw_up_PCA_projection.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"So many ways to screw up PCA projection","text":"run prcomp get two matrices back: $x $rotation. former “pattern matrix” factors (principal components) samples. latter amplitude matrix, loadings features (genes) factors (principal compoent); row column, respectively. theory can use rotation (loadings) matrix prcomp ($rotation slot) multiply new matrix get new matrix eigenvector space original matrix. handy! means can use existing PCA understand spent time interpreting transfer knowledge onto new data. practice, though, wide variety reasons can fail. Let us explore .","code":""},{"path":"https://davemcg.github.io/metamoRph/articles/So_many_ways_to_screw_up_PCA_projection.html","id":"toy-data","dir":"Articles","previous_headings":"","what":"Toy Data","title":"So many ways to screw up PCA projection","text":"Let’s make tiny little faux dataset. Threetissue types five genes. log1p scale data raw gene counts skewed, run prcomp, plot first two principal components (PC). nice job turning three major axes variation two informative eigenvalues/PCs.","code":"library(dplyr) library(ggplot2)  genes <- c('RHO','RPE65','ABCA4','PMEL', 'KRT5') samples <- c('Retina1','Retina2','RPE1','RPE2','Cornea1')  faux_mat <- cbind(c(560,650,5,6,0), # rho                   c(42,32, 1103,1201,2), #rpe65                   c(810,903,202,205,45),  #abca4                   c(100,105,2004,1980,101),# pmel                   c(3,32,101,202,1567)) |> data.frame()# krt5 colnames(faux_mat) <- genes row.names(faux_mat) <- samples  faux_pca <- prcomp(log1p(faux_mat), scale = TRUE, center = TRUE)  faux_pca$x |>   as_tibble(rownames = 'samples') |>   mutate(samples = gsub('\\\\d','',samples)) |>   ggplot(aes(x=PC1,y=PC2,color=samples)) +    geom_point() +   cowplot::theme_cowplot()"},{"path":"https://davemcg.github.io/metamoRph/articles/So_many_ways_to_screw_up_PCA_projection.html","id":"matrix-multiplication","dir":"Articles","previous_headings":"Toy Data","what":"Matrix Multiplication","title":"So many ways to screw up PCA projection","text":"pattern matrix (plotted ) can recreated multiplying input_matrix rotation matrix ($rotation slot). Wait, ’s wrong….numbers different. PC1 range -2 2, now runs -5 3. happened? investigate prcomp documentation see input data, default, scaled across features. apply scale function log1p scaled faux_mat get matrix exactly matches prcomp $x slot.","code":"as.matrix(log1p(faux_mat)) %*% faux_pca$rotation #>                PC1       PC2       PC3      PC4        PC5 #> Retina1 -5.3069381  6.663913 -6.742996 1.019740  1.7946458 #> Retina2 -4.2997533  6.180512 -8.561370 1.023196  1.8633885 #> RPE1     0.6846905 10.185969 -7.344765 1.244264 -0.1409538 #> RPE2     0.9614531 10.129915 -7.975298 1.080184 -0.1129111 #> Cornea1  3.0978105  3.285634 -7.889147 2.953432 -0.1903413 scale(log1p(faux_mat)) %*% faux_pca$rotation #>                PC1        PC2         PC3           PC4           PC5 #> Retina1 -2.0431901 -0.3037915  0.39056644 -0.0106105643 -1.731409e-16 #> Retina2 -1.5974315 -0.4984942 -0.44451477  0.0106690878  1.540995e-16 #> RPE1     0.7816114  1.3692855  0.13985224  0.0318634972  5.206909e-16 #> RPE2     0.9130827  1.3399136 -0.14113664 -0.0315408477  4.522474e-16 #> Cornea1  1.9459275 -1.9069134  0.05523273 -0.0003811731  3.959764e-16  (scale(log1p(faux_mat)) %*% faux_pca$rotation) == faux_pca$x #>          PC1  PC2  PC3  PC4  PC5 #> Retina1 TRUE TRUE TRUE TRUE TRUE #> Retina2 TRUE TRUE TRUE TRUE TRUE #> RPE1    TRUE TRUE TRUE TRUE TRUE #> RPE2    TRUE TRUE TRUE TRUE TRUE #> Cornea1 TRUE TRUE TRUE TRUE TRUE"},{"path":"https://davemcg.github.io/metamoRph/articles/So_many_ways_to_screw_up_PCA_projection.html","id":"three-fake-cornea-tissues","dir":"Articles","previous_headings":"Toy Data","what":"Three fake cornea tissues","title":"So many ways to screw up PCA projection","text":"Now new data. Three cornea samples. want compare new cornea samples existing PCA see compare. discussed , able just matrix multiply new matrix original pca $loading slot put new data PC space.","code":"new_data <- cbind(c(5,6,3), # rho                   c(32,23,54), #rpe65                   c(65,22,10),  #abca4                   c(122,101,57),# pmel                   c(2567,1755,2218)) # krt5 colnames(new_data) <- genes row.names(new_data) <- c(\"Cornea2\",\"Cornea3\",\"Cornea4\")"},{"path":"https://davemcg.github.io/metamoRph/articles/So_many_ways_to_screw_up_PCA_projection.html","id":"ok-lets-try-projecting-some-new-data","dir":"Articles","previous_headings":"","what":"OK, let’s try projecting some new data!","title":"So many ways to screw up PCA projection","text":"apply knowledge scale new data matrix multiply rotation matrix. ? three new samples … middle??? ??????","code":"new_project <- scale(log1p(new_data)) %*% faux_pca$rotation  # we bind rows to glue together the original PCA (faux_pca$x) # with the new data's PC space (new_project) bind_rows(as_tibble(faux_pca$x, rownames = 'samples'),       as_tibble(new_project, rownames = 'samples')) |>   mutate(samples = gsub('\\\\d','',samples)) |>   ggplot(aes(x=PC1,y=PC2,color=samples)) +    geom_point() +   cowplot::theme_cowplot()"},{"path":"https://davemcg.github.io/metamoRph/articles/So_many_ways_to_screw_up_PCA_projection.html","id":"what-scale-does","dir":"Articles","previous_headings":"","what":"What scale does","title":"So many ways to screw up PCA projection","text":"scale takes columns , default, center (mean 0) scale (divide standard deviation). issue one sample type fairly similar expression patterns across genes, scaling turns everything similar values. centers around 0, effect multiplying prcomp rotation matrix.","code":"scale(new_data) #>                RHO      RPE65      ABCA4       PMEL       KRT5 #> Cornea2  0.2182179 -0.2717193  1.1295751  0.8642016  0.9500860 #> Cornea3  0.8728716 -0.8360593 -0.3573146  0.2311237 -1.0433761 #> Cornea4 -1.0910895  1.1077786 -0.7722605 -1.0953253  0.0932901 #> attr(,\"scaled:center\") #>         RHO       RPE65       ABCA4        PMEL        KRT5  #>    4.666667   36.333333   32.333333   93.333333 2180.000000  #> attr(,\"scaled:scale\") #>        RHO      RPE65      ABCA4       PMEL       KRT5  #>   1.527525  15.947832  28.919428  33.171273 407.331560"},{"path":[]},{"path":"https://davemcg.github.io/metamoRph/articles/So_many_ways_to_screw_up_PCA_projection.html","id":"with-statspredict","dir":"Articles","previous_headings":"How to fix?","what":"with stats::predict","title":"So many ways to screw up PCA projection","text":"use stats::predict tool, use scaling information prcomp object scale new data scale center values used prcomp scale/center steps.","code":"with_predict <- predict(faux_pca, (log1p(new_data)))  bind_rows(as_tibble(faux_pca$x, rownames = 'samples'),       as_tibble(with_predict, rownames = 'samples')) |>   mutate(samples = gsub('\\\\d','',samples)) |>   ggplot(aes(x=PC1,y=PC2,color=samples)) +    geom_point() +   cowplot::theme_cowplot()"},{"path":[]},{"path":"https://davemcg.github.io/metamoRph/articles/So_many_ways_to_screw_up_PCA_projection.html","id":"plot-twist","dir":"Articles","previous_headings":"Yay all is well in the world!","what":"plot twist","title":"So many ways to screw up PCA projection","text":"RNA-seq data common wildly different sum counts. sequencing machine can create 10,000,000 reads one sample 100,000,000 reads. even ! Let’s try stats::prcomp new_data, just scaled 10x. Well ugh, look, now new cornea samples look like RPE!!!!!","code":"with_predict <- predict(faux_pca, (log1p(new_data*10)))  bind_rows(as_tibble(faux_pca$x, rownames = 'samples'),       as_tibble(with_predict, rownames = 'samples')) |>   mutate(samples = gsub('\\\\d','',samples)) |>   ggplot(aes(x=PC1,y=PC2,color=samples)) +    geom_point() +   cowplot::theme_cowplot()"},{"path":"https://davemcg.github.io/metamoRph/articles/So_many_ways_to_screw_up_PCA_projection.html","id":"ok-so-this-is-fixable-","dir":"Articles","previous_headings":"Yay all is well in the world!","what":"OK, so this is fixable….","title":"So many ways to screw up PCA projection","text":"can either re-original PCA fixed sample scale (like cpm) /alter new data similar scale input data PCA. recap, point discussed several issues can make data projection challenging: log scaling input data log scaling new data row scaling (feature/genes) within prcomp needs applied way new data unequal sum counts samples need normalized either first prcomp step adjusting new data even little annoyances discussed: highly variable gene selection usually done don’t PCA 20,000+ genes. means new data needs exactly matched feature/gene level whatever highly variable genes used prcomp step using new RNA seq dataset different quantification setup original data gene names can slightly different, means may handful missing features/genes addressed way otherwise matrix multiplication fail…","code":""},{"path":[]},{"path":"https://davemcg.github.io/metamoRph/articles/So_many_ways_to_screw_up_PCA_projection.html","id":"good-news-i-did-metamorph","dir":"Articles","previous_headings":"wow, if only someone wrote a R package that could handle all of the issues so I can get on with my analysis!","what":"Good news, I did: metamoRph","title":"So many ways to screw up PCA projection","text":"two steps: run_pca wrapper around prcomp , default, : CPM scale samples log1p scale data remove zero count genes row scale center genes tries remove mitochondrial ribosomal genes often useful scRNA analysis offers two ways select highly variable genes: “scran” uses count scaled variance selection approach (higher expressed genes/features naturally higher variance) “classic” approach just uses matrixStats::rowVar calculates % standard deviation explained PC returns list object prcomp object, parameters chosen, center/scale values, % standard deviation explained PC metamoRph function takes two three inputs: new counts matrix $rotation matrix prcomp optionally center/scale values prcomp align feature/gene names input data rotation matrix scale data directions discussed return $x equivalent PC space Let’s see practice 10x scaled input data tripped stats::predict two two steps: run_pca runs prcomp settings discussed metamoRph takes new data projects onto mm_pca space","code":"library(metamoRph) mm_pca <- run_pca(t(faux_mat), meta = samples |> data.frame()) projected_pca <- metamoRph(t(new_data*10),                                 mm_pca$PCA$rotation,                                 center_scale = mm_pca$center_scale)  bind_rows(as_tibble(faux_pca$x, rownames = 'samples'),       as_tibble(projected_pca, rownames = 'samples')) |>   mutate(samples = gsub('\\\\d','',samples)) |>   ggplot(aes(x=PC1,y=PC2,color=samples)) +    geom_point() +   cowplot::theme_cowplot() sessionInfo() #> R version 4.3.0 (2023-04-21) #> Platform: aarch64-apple-darwin20 (64-bit) #> Running under: macOS Ventura 13.4.1 #>  #> Matrix products: default #> BLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib  #> LAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0 #>  #> locale: #> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 #>  #> time zone: America/New_York #> tzcode source: internal #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] metamoRph_0.1 ggplot2_3.4.2 dplyr_1.1.2   #>  #> loaded via a namespace (and not attached): #>  [1] tidyselect_1.2.0            farver_2.1.1                #>  [3] bitops_1.0-7                fastmap_1.1.1               #>  [5] SingleCellExperiment_1.22.0 RCurl_1.98-1.12             #>  [7] bluster_1.9.1               digest_0.6.31               #>  [9] rsvd_1.0.5                  lifecycle_1.0.3             #> [11] cluster_2.1.4               statmod_1.5.0               #> [13] magrittr_2.0.3              compiler_4.3.0              #> [15] rlang_1.1.1                 sass_0.4.6                  #> [17] tools_4.3.0                 igraph_1.4.3                #> [19] utf8_1.2.3                  yaml_2.3.7                  #> [21] knitr_1.43                  S4Arrays_1.0.4              #> [23] labeling_0.4.2              dqrng_0.3.0                 #> [25] DelayedArray_0.26.6         BiocParallel_1.33.11        #> [27] withr_2.5.0                 purrr_1.0.1                 #> [29] BiocGenerics_0.46.0         desc_1.4.2                  #> [31] grid_4.3.0                  stats4_4.3.0                #> [33] fansi_1.0.4                 beachmat_2.15.0             #> [35] colorspace_2.1-0            edgeR_3.42.2                #> [37] scales_1.2.1                SummarizedExperiment_1.30.1 #> [39] cli_3.6.1                   rmarkdown_2.21              #> [41] crayon_1.5.2                ragg_1.2.5                  #> [43] generics_0.1.3              metapod_1.7.0               #> [45] rstudioapi_0.14             DelayedMatrixStats_1.21.0   #> [47] scuttle_1.9.4               cachem_1.0.8                #> [49] stringr_1.5.0               zlibbioc_1.46.0             #> [51] parallel_4.3.0              XVector_0.40.0              #> [53] matrixStats_0.63.0          vctrs_0.6.2                 #> [55] Matrix_1.5-4.1              jsonlite_1.8.4              #> [57] BiocSingular_1.15.0         IRanges_2.34.0              #> [59] S4Vectors_0.38.1            BiocNeighbors_1.17.1        #> [61] irlba_2.3.5.1               systemfonts_1.0.4           #> [63] locfit_1.5-9.7              limma_3.56.1                #> [65] tidyr_1.3.0                 jquerylib_0.1.4             #> [67] glue_1.6.2                  pkgdown_2.0.7               #> [69] codetools_0.2-19            cowplot_1.1.1               #> [71] stringi_1.7.12              gtable_0.3.3                #> [73] GenomeInfoDb_1.36.0         GenomicRanges_1.52.0        #> [75] ScaledMatrix_1.8.1          munsell_0.5.0               #> [77] tibble_3.2.1                pillar_1.9.0                #> [79] htmltools_0.5.5             GenomeInfoDbData_1.2.10     #> [81] R6_2.5.1                    textshaping_0.3.6           #> [83] sparseMatrixStats_1.11.1    rprojroot_2.0.3             #> [85] evaluate_0.21               Biobase_2.60.0              #> [87] lattice_0.21-8              highr_0.10                  #> [89] memoise_2.0.1               scran_1.27.1                #> [91] bslib_0.5.0                 Rcpp_1.0.10                 #> [93] xfun_0.39                   fs_1.6.2                    #> [95] MatrixGenerics_1.12.0       pkgconfig_2.0.3"},{"path":"https://davemcg.github.io/metamoRph/articles/build_a_brain_region_predictor.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Build and Apply a Human Brain Region Predictor in 60 seconds or less","text":"GTEx resource contains thousands human RNA-seq tissues. use recount3 package pull GTEx brain RNA-seq datasets, use subset build brain region predictor, apply remaining GTEx brain data bring outside human brain study see whether model still useful.","code":""},{"path":"https://davemcg.github.io/metamoRph/articles/build_a_brain_region_predictor.html","id":"pull-in-gtex-brain-counts-via-recount3","dir":"Articles","previous_headings":"","what":"Pull in GTEx brain counts via recount3","title":"Build and Apply a Human Brain Region Predictor in 60 seconds or less","text":"longest step vignette. Takes 10-20 seconds, though time vary depending vagaries internet. show gtex.smtsd see brain regions assayed GTEx.","code":"library(ggplot2) library(dplyr) library(recount3) library(metamoRph) human_projects <- available_projects()  project_info <- subset(human_projects, file_source == \"gtex\" & project_type == \"data_sources\" & project == 'BRAIN')  rse_gene_brain <- create_rse(project_info)  colData(rse_gene_brain)$gtex.smtsd %>% table() #> . #>                          Brain - Amygdala  Brain - Anterior cingulate cortex (BA24)           Brain - Caudate (basal ganglia)  #>                                       163                                       201                                       273  #>             Brain - Cerebellar Hemisphere                        Brain - Cerebellum                            Brain - Cortex  #>                                       250                                       285                                       286  #>              Brain - Frontal Cortex (BA9)                       Brain - Hippocampus                      Brain - Hypothalamus  #>                                       224                                       220                                       221  #> Brain - Nucleus accumbens (basal ganglia)           Brain - Putamen (basal ganglia)        Brain - Spinal cord (cervical c-1)  #>                                       262                                       221                                       171  #>                  Brain - Substantia nigra  #>                                       154"},{"path":"https://davemcg.github.io/metamoRph/articles/build_a_brain_region_predictor.html","id":"extract-read-counts","dir":"Articles","previous_headings":"","what":"Extract read counts","title":"Build and Apply a Human Brain Region Predictor in 60 seconds or less","text":"","code":"brain_counts <- compute_read_counts(rse_gene_brain)"},{"path":"https://davemcg.github.io/metamoRph/articles/build_a_brain_region_predictor.html","id":"build-metadata-table-for-the-train-and-project-data","dir":"Articles","previous_headings":"","what":"Build metadata table for the “train” and “project” data","title":"Build and Apply a Human Brain Region Predictor in 60 seconds or less","text":"train data used build PCA object. PCA data used model building. project data morphed/projected onto PCA space metamoRph output used model_apply guess tissue label. happens less 10 seconds MacBook.","code":"set.seed(20230711) train_meta <- colData(rse_gene_brain) %>% as_tibble(rownames = 'id') %>% group_by(gtex.smtsd) %>% sample_n(40) project_meta <- colData(rse_gene_brain) %>% as_tibble(rownames = 'id') %>% filter(!id %in% train_meta$id)  train_counts <- brain_counts[,train_meta$id] project_counts <- brain_counts[,project_meta$id]  gtex_pca <-  run_pca(train_counts, train_meta)  trained_model <- model_build(gtex_pca$PCA$x,                              gtex_pca$meta %>% pull(gtex.smtsd),                              model = 'lm', verbose = FALSE)  projected_data <- metamoRph(project_counts,                             gtex_pca$PCA$rotation,                             gtex_pca$center_scale) # apply model label_guesses <- model_apply(trained_model,                              projected_data,                              project_meta %>% pull(gtex.smtsd))"},{"path":"https://davemcg.github.io/metamoRph/articles/build_a_brain_region_predictor.html","id":"accuracy","dir":"Articles","previous_headings":"","what":"Accuracy","title":"Build and Apply a Human Brain Region Predictor in 60 seconds or less","text":"","code":"num_correct <- label_guesses %>% filter(sample_label == predict) %>% nrow() num_wrong <- label_guesses %>% filter(sample_label != predict) %>% nrow()  # accuracy num_correct / (num_correct + num_wrong) #> [1] 0.9261717"},{"path":"https://davemcg.github.io/metamoRph/articles/build_a_brain_region_predictor.html","id":"visualizing-the-label-outcomes-on-the-pc","dir":"Articles","previous_headings":"","what":"Visualizing the label outcomes on the PC","title":"Build and Apply a Human Brain Region Predictor in 60 seconds or less","text":"can see many “misablels” edge (!) groups.","code":"bind_rows(projected_data %>% as_tibble(rownames = 'id')) %>%   left_join(colData(rse_gene_brain) %>% as_tibble(rownames = 'id'), by = 'id') %>%   left_join(label_guesses, by = c(\"id\"= \"sample_id\")) %>%   mutate(correct = case_when(sample_label == predict ~ 'Yes',                              TRUE ~ 'No')) %>%   ggplot(aes(x=PC1,y=PC2,color = correct)) + geom_point(alpha = 0.5) +   cowplot::theme_cowplot()+   facet_wrap(~gtex.smtsd)"},{"path":"https://davemcg.github.io/metamoRph/articles/build_a_brain_region_predictor.html","id":"now-a-harder-thing---using-outside-data-on-the-model-we-built","dir":"Articles","previous_headings":"","what":"Now a harder thing - using outside data on the model we built","title":"Build and Apply a Human Brain Region Predictor in 60 seconds or less","text":"BA9 prefontal cortex - model built still ~90% accuracy.","code":"# outside brain prefrontal cortex (BA9) outside_gtex <- subset(human_projects,  project_type == \"data_sources\" & project == 'SRP058181') rse_gene_outside <- create_rse(outside_gtex)  outside_counts <- compute_read_counts(rse_gene_outside) outside_meta <- colData(rse_gene_outside) %>% as_tibble(rownames = 'id') outside_counts <- outside_counts[,outside_meta$id]   projected_data_outside <- metamoRph(outside_counts,                                     gtex_pca$PCA$rotation,                                     gtex_pca$center_scale) label_guesses_outside <- model_apply(trained_model,                                      projected_data_outside)"},{"path":"https://davemcg.github.io/metamoRph/articles/build_a_brain_region_predictor.html","id":"accuracy-1","dir":"Articles","previous_headings":"Now a harder thing - using outside data on the model we built","what":"Accuracy","title":"Build and Apply a Human Brain Region Predictor in 60 seconds or less","text":"","code":"num_correct <- label_guesses_outside %>% filter(grepl(\"BA9\", predict)) %>% nrow() num_wrong <- label_guesses_outside %>% filter(!grepl(\"BA9\", predict)) %>% nrow()  # accuracy num_correct / (num_correct + num_wrong) #> [1] 0.8767123"},{"path":"https://davemcg.github.io/metamoRph/articles/build_a_brain_region_predictor.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"Build and Apply a Human Brain Region Predictor in 60 seconds or less","text":"","code":"sessionInfo() #> R version 4.3.0 (2023-04-21) #> Platform: aarch64-apple-darwin20 (64-bit) #> Running under: macOS Ventura 13.4.1 #>  #> Matrix products: default #> BLAS:   /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib  #> LAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0 #>  #> locale: #> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 #>  #> time zone: America/New_York #> tzcode source: internal #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #>  [1] metamoRph_0.1               knitr_1.43                  ggplot2_3.4.2               BiocParallel_1.33.11        dplyr_1.1.2                 #>  [6] recount3_1.10.2             SummarizedExperiment_1.30.1 Biobase_2.60.0              GenomicRanges_1.52.0        GenomeInfoDb_1.36.0         #> [11] IRanges_2.34.0              S4Vectors_0.38.1            BiocGenerics_0.46.0         MatrixGenerics_1.12.0       matrixStats_0.63.0          #>  #> loaded via a namespace (and not attached): #>   [1] fs_1.6.2                    bitops_1.0-7                xopen_1.0.0                 devtools_2.4.5              lubridate_1.9.2             #>   [6] DiceDesign_1.9              httr_1.4.6                  profvis_0.3.8               tools_4.3.0                 backports_1.4.1             #>  [11] utf8_1.2.3                  R6_2.5.1                    ResidualMatrix_1.10.0       HDF5Array_1.28.1            lazyeval_0.2.2              #>  [16] yardstick_1.2.0             rhdf5filters_1.12.1         urlchecker_1.0.1            withr_2.5.0                 prettyunits_1.1.1           #>  [21] cli_3.6.1                   labeling_0.4.2              tune_1.1.1                  askpass_1.1                 pkgdown_2.0.7               #>  [26] commonmark_1.9.0            Rsamtools_2.15.2            R.utils_2.12.2              dichromat_2.0-0.1           parallelly_1.36.0           #>  [31] sessioninfo_1.2.2           maps_3.4.1                  limma_3.56.1                rstudioapi_0.14             RSQLite_2.3.1               #>  [36] pals_1.7                    generics_0.1.3              BiocIO_1.9.2                Matrix_1.5-4.1              fansi_1.0.4                 #>  [41] R.methodsS3_1.8.2           lifecycle_1.0.3             yaml_2.3.7                  edgeR_3.42.2                rhdf5_2.44.0                #>  [46] recipes_1.0.6               BiocFileCache_2.7.2         grid_4.3.0                  blob_1.2.4                  promises_1.2.0.1            #>  [51] dqrng_0.3.0                 crayon_1.5.2                miniUI_0.1.1.1              lattice_0.21-8              beachmat_2.15.0             #>  [56] cowplot_1.1.1               mapproj_1.2.11              pillar_1.9.0                metapod_1.7.0               rjson_0.2.21                #>  [61] future.apply_1.11.0         codetools_0.2-19            glue_1.6.2                  rsample_1.1.1               data.table_1.14.8           #>  [66] remotes_2.4.2               workflowsets_1.0.1          vctrs_0.6.2                 png_0.1-8                   testthat_3.1.8              #>  [71] rcmdcheck_1.4.0             gtable_0.3.3                cachem_1.0.8                gower_1.0.1                 xfun_0.39                   #>  [76] S4Arrays_1.0.4              mime_0.12                   prodlim_2023.03.31          DropletUtils_1.20.0         survival_3.5-5              #>  [81] timeDate_4022.108           SingleCellExperiment_1.22.0 iterators_1.0.14            hardhat_1.3.0               lava_1.7.2.1                #>  [86] statmod_1.5.0               bluster_1.9.1               ellipsis_0.3.2              ipred_0.9-14                modeldata_1.1.0             #>  [91] infer_1.0.4                 usethis_2.1.6               bit64_4.0.5                 filelock_1.0.2              rprojroot_2.0.3             #>  [96] irlba_2.3.5.1               rpart_4.1.19                colorspace_2.1-0            DBI_1.1.3                   nnet_7.3-19                 #> [101] tidyselect_1.2.0            processx_3.8.1              bit_4.0.5                   compiler_4.3.0              curl_5.0.0                  #> [106] BiocNeighbors_1.17.1        tidymodels_1.1.0            xml2_1.3.4                  desc_1.4.2                  DelayedArray_0.26.6         #> [111] plotly_4.10.1               rtracklayer_1.59.1          scales_1.2.1                callr_3.7.3                 stringr_1.5.0               #> [116] digest_0.6.31               rmarkdown_2.21              XVector_0.40.0              htmltools_0.5.5             pkgconfig_2.0.3             #> [121] umap_0.2.10.0               sparseMatrixStats_1.11.1    lhs_1.1.6                   highr_0.10                  dbplyr_2.3.2                #> [126] fastmap_1.1.1               rlang_1.1.1                 htmlwidgets_1.6.2           shiny_1.7.4                 DelayedMatrixStats_1.21.0   #> [131] farver_2.1.1                jsonlite_1.8.4              R.oo_1.25.0                 BiocSingular_1.15.0         RCurl_1.98-1.12             #> [136] magrittr_2.0.3              scuttle_1.9.4               GenomeInfoDbData_1.2.10     Rhdf5lib_1.22.0             munsell_0.5.0               #> [141] GPfit_1.0-8                 Rcpp_1.0.10                 reticulate_1.28             furrr_0.3.1                 stringi_1.7.12              #> [146] brio_1.1.3                  zlibbioc_1.46.0             MASS_7.3-60                 pkgbuild_1.4.0              parallel_4.3.0              #> [151] listenv_0.9.0               Biostrings_2.67.2           splines_4.3.0               locfit_1.5-9.7              ps_1.7.5                    #> [156] igraph_1.4.3                dials_1.2.0                 parsnip_1.1.0               ScaledMatrix_1.8.1          pkgload_1.3.2               #> [161] XML_3.99-0.14               evaluate_0.21               scran_1.27.1                foreach_1.5.2               httpuv_1.6.11               #> [166] batchelor_1.15.1            tidyr_1.3.0                 openssl_2.0.6               purrr_1.0.1                 future_1.32.0               #> [171] rsvd_1.0.5                  broom_1.0.4                 xtable_1.8-4                restfulr_0.0.15             RSpectra_0.16-1             #> [176] roxygen2_7.2.3              later_1.3.1                 viridisLite_0.4.2           class_7.3-22                tibble_3.2.1                #> [181] memoise_2.0.1               GenomicAlignments_1.35.1    cluster_2.1.4               workflows_1.1.3             timechange_0.2.0            #> [186] globals_0.16.2"},{"path":"https://davemcg.github.io/metamoRph/articles/real_data_testing.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Metadata Label Transfer on Real Data","text":"take data EiaD resource, cut dozen cornea, retina, RPE samples well first thousand variable genes (calculated variance).","code":""},{"path":"https://davemcg.github.io/metamoRph/articles/real_data_testing.html","id":"load-libraries","dir":"Articles","previous_headings":"","what":"Load libraries","title":"Metadata Label Transfer on Real Data","text":"","code":"library(projectR) library(metamoRph) library(dplyr) library(ggplot2)"},{"path":"https://davemcg.github.io/metamoRph/articles/real_data_testing.html","id":"import-eiad-data","dir":"Articles","previous_headings":"","what":"Import EiaD data","title":"Metadata Label Transfer on Real Data","text":"ocular subset full resource (full data can found eyeIntegration.nei.nih.gov)","code":"feature_by_sample <- data.table::fread(   system.file('test_data/EiaD__eye_samples_counts.csv.gz', package = 'metamoRph') ) genes <- feature_by_sample$Gene feature_by_sample <- feature_by_sample[,-1] %>% as.matrix() row.names(feature_by_sample) <- genes meta_ref <- data.table::fread(   system.file('test_data/EiaD__eye_samples_metaRef.csv.gz', package = 'metamoRph') ) meta_project <- data.table::fread(    system.file('test_data/EiaD__eye_samples_metaProject.csv.gz', package = 'metamoRph') )"},{"path":"https://davemcg.github.io/metamoRph/articles/real_data_testing.html","id":"projectr","dir":"Articles","previous_headings":"","what":"projectR","title":"Metadata Label Transfer on Real Data","text":"projectR apply prcomp row (gene) scaling, new data ends center PCA plot. Scaling new data alone also results variation samples exaggerated.","code":"ref_matrix <- feature_by_sample[,meta_ref %>% pull(sample_accession)] Pvars <- matrixStats::rowVars(log1p(ref_matrix)) select <- order(Pvars, decreasing = TRUE)[seq_len(min(1000,                                                       length(Pvars)))]  pr_run <- prcomp(log1p(t(ref_matrix[select,])),                  scale = TRUE,                  center = TRUE)  new_mat_for_projection <- feature_by_sample[select,                                             meta_project %>% pull(sample_accession)]  pr_proj <- projectR(data = log1p(as.matrix(new_mat_for_projection)),                     loadings = pr_run,                     dataNames = row.names(new_mat_for_projection)) #> [1] \"1000 row names matched between data and loadings\" #> [1] \"Updated dimension of data: 1000 12\"  data_plot <- bind_rows(cbind(t(pr_proj), meta_project %>%                                mutate(Tissue = paste0(Tissue, \" Projected\"), Data = 'Projection')),                        cbind(pr_run$x, meta_ref)) data_plot %>%   mutate(Tissue = case_when(Cohort == 'Body' ~ 'Body', TRUE ~ Tissue)) %>%   ggplot(aes(x=PC1,y=PC2, color = Tissue)) + geom_point() +   ggforce::geom_mark_circle(data = data_plot %>% filter(Data == 'Projection'), color = 'red', expand = unit(2,\"mm\"), size = 2) +   scale_color_manual(values = pals::alphabet(n=12)%>% unname()) + cowplot::theme_cowplot()"},{"path":"https://davemcg.github.io/metamoRph/articles/real_data_testing.html","id":"metamorph","dir":"Articles","previous_headings":"","what":"metamoRph","title":"Metadata Label Transfer on Real Data","text":"metamoRph’s two steps (run_pca metamoRph) gets new data proper scale projection work properly.","code":"pca_output <- run_pca(feature_by_sample = ref_matrix[select,],                       meta = meta_ref,                       hvg_selection = 'classic',                       sample_cpm_scale = FALSE)  # project data from the pca rownames(new_mat_for_projection) <- gsub(' \\\\(.*','',rownames(new_mat_for_projection)) projected_data <- metamoRph(new_mat_for_projection,                             pca_output$PCA$rotation,                             center_scale = pca_output$center_scale,                             sample_cpm_scale =  FALSE) data_plot <- bind_rows(cbind(projected_data, meta_project %>%                                mutate(Tissue = paste0(Tissue, \" Projected\"),                                       Data = 'Projection')),                        cbind(pca_output$PCA$x, meta_ref) %>%                          mutate(Data = 'Original')) data_plot %>%   mutate(Tissue = case_when(Cohort == 'Body' ~ 'Body', TRUE ~ Tissue)) %>%   ggplot(aes(x=PC1,y=PC2,color = Tissue)) +   geom_point() +   scale_color_manual(values = pals::alphabet(n=12) %>% unname()) +   ggforce::geom_mark_ellipse(data = data_plot %>% filter(Data == 'Projection'), color = 'red', size = 2) +   ggforce::geom_mark_ellipse() +      cowplot::theme_cowplot()"},{"path":"https://davemcg.github.io/metamoRph/articles/real_data_testing.html","id":"metamorph-with-cpm-scaling-and-scran-hvg-selection","dir":"Articles","previous_headings":"","what":"metamoRph with cpm scaling and scran HVG selection","title":"Metadata Label Transfer on Real Data","text":"CPM scran steps modestly improves PC1/PC2 distinction tissue types well pulling outliers back towards matching tissue type.","code":"pca_output <- run_pca(ref_matrix[select,],                       meta_ref,                       hvg_selection = 'scran',                       sample_cpm_scale = TRUE)  # project data from the pca projected_data <- metamoRph(new_mat_for_projection,                             pca_output$PCA$rotation,                             center_scale = pca_output$center_scale,                             sample_cpm_scale = TRUE)  data_plot <- bind_rows(cbind(projected_data, meta_project %>%                                mutate(Tissue = paste0(Tissue, \" Projected\"),                                       Data = 'Projection')),                        cbind(pca_output$PCA$x, meta_ref) %>%                          mutate(Data = 'Original')) data_plot %>%   mutate(Tissue = case_when(Cohort == 'Body' ~ 'Body', TRUE ~ Tissue)) %>%   ggplot(aes(x=PC1,y=PC2,color = Tissue)) +   geom_point() +   scale_color_manual(values = pals::alphabet(n=12) %>% unname()) +   ggforce::geom_mark_ellipse(data = data_plot %>% filter(Data == 'Projection'), color = 'red', size = 2) +     ggforce::geom_mark_ellipse() +   cowplot::theme_cowplot()"},{"path":"https://davemcg.github.io/metamoRph/articles/real_data_testing.html","id":"label-transfer","dir":"Articles","previous_headings":"","what":"Label Transfer","title":"Metadata Label Transfer on Real Data","text":"Finally demonstrate two step process transferring labels input data onto projected data. First run model_build original pca_output eigenvalue matrix ($x). also provide label data interest transfer (tissue). Behind scenes lm model built unique label (case tissue) tissues using first 10 PCs. output list models (one tissue type). can use list models model_apply well projected data metamoRph. provide (optional) true labels projected data. tibble returned gives original label (provided) sample_label field well predicted label (predict) field. max_score confidence model prediction. Closer 0 low confidence closer 1 high confidence.","code":"trained_model <- model_build(pca_output$PCA$x,                              pca_output$meta$Tissue,                              model = 'lm', num_PCs = 10, verbose = FALSE,                              BPPARAM = MulticoreParam(10))  label_guesses <- model_apply(trained_model,                              projected_data,                              meta_project$Tissue )  label_guesses #> # A tibble: 12 × 6 #>    sample_id  sample_label predict predict_second    predict_stringent max_score #>    <chr>      <chr>        <chr>   <chr>             <chr>                 <dbl> #>  1 SRS8476047 Retina       Retina  Conjunctiva       Retina                0.980 #>  2 SRS8476048 Retina       Retina  Conjunctiva       Retina                1.06  #>  3 SRS8476049 Retina       Retina  Conjunctiva       Retina                1.05  #>  4 SRS8476039 Retina       Retina  Conjunctiva       Retina                1.00  #>  5 SRS8476038 Retina       Retina  Trabecular Meshw… Retina                1.03  #>  6 SRS8476040 Retina       Retina  Trabecular Meshw… Retina                1.00  #>  7 SRS8476041 Retina       Retina  Trabecular Meshw… Retina                1.03  #>  8 SRS8476042 Retina       Retina  Conjunctiva       Retina                0.986 #>  9 SRS8476043 Retina       Retina  Trabecular Meshw… Retina                1.03  #> 10 SRS8476044 Retina       Retina  Trabecular Meshw… Retina                0.979 #> 11 SRS8476045 Retina       Retina  Trabecular Meshw… Retina                1.03  #> 12 SRS8476046 Retina       Retina  Conjunctiva       Retina                1.06"},{"path":"https://davemcg.github.io/metamoRph/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"David McGaughey. Author, maintainer.","code":""},{"path":"https://davemcg.github.io/metamoRph/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"McGaughey D (2023). metamoRph: Metadata projection via data morphing matrix factorization multiplication. R package version 0.1.2, https://davemcg.github.io/metamoRph/.","code":"@Manual{,   title = {metamoRph: Metadata projection via data morphing with matrix factorization multiplication},   author = {David McGaughey},   year = {2023},   note = {R package version 0.1.2},   url = {https://davemcg.github.io/metamoRph/}, }"},{"path":"https://davemcg.github.io/metamoRph/index.html","id":"metamorph","dir":"","previous_headings":"","what":"Metadata projection via data morphing with matrix factorization multiplication","title":"Metadata projection via data morphing with matrix factorization multiplication","text":"framework projecting new data onto reference PCA space. can two step process user runs run_pca function (wraps prcomp provides sensible defaults enhanced outputs. run_pca user can use metamoRph project new data onto existing PCA. also provides two functions, model_build model_apply quickly transfer metadata onto new data using shared PCA space.","code":""},{"path":"https://davemcg.github.io/metamoRph/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick Start","title":"Metadata projection via data morphing with matrix factorization multiplication","text":"","code":"remotes::install_github(\"davemcg/metamoRph\") library(metamoRph) library(dplyr) library(ggplot2) library(dplyr) library(ggplot2)  genes <- c('RHO','RPE65','ABCA4','PMEL', 'KRT5') samples <- c('Retina1','Retina2','RPE1','RPE2','Cornea1')  faux_mat <- cbind(c(560,650,5,6,0), # rho                   c(42,32, 1103,1201,2), #rpe65                   c(810,903,202,205,45),  #abca4                   c(100,105,2004,1980,101),# pmel                   c(3,32,101,202,1567)) |> data.frame()# krt5 colnames(faux_mat) <- genes row.names(faux_mat) <- samples  new_data <- cbind(c(5,6,3), # rho                   c(32,23,54), #rpe65                   c(65,22,10),  #abca4                   c(122,101,57),# pmel                   c(2567,1755,2218)) * 100 # krt5 colnames(new_data) <- genes row.names(new_data) <- c(\"Cornea2\",\"Cornea3\",\"Cornea4\")  mm_pca <- run_pca(t(faux_mat), meta = samples |> data.frame()) projected_pca <- metamoRph(t(new_data),                                 mm_pca$PCA$rotation,                                 center_scale = mm_pca$center_scale)  # example plot # bind_rows(as_tibble(mm_pca$PCA$x, rownames = 'samples'), #       as_tibble(projected_pca, rownames = 'Cornea')) |> #   mutate(samples = gsub('\\\\d','',samples)) |> #   ggplot(aes(x=PC1,y=PC2,color=samples)) +  #   geom_point() + #   cowplot::theme_cowplot()"},{"path":"https://davemcg.github.io/metamoRph/index.html","id":"label-projection","dir":"","previous_headings":"","what":"Label projection","title":"Metadata projection via data morphing with matrix factorization multiplication","text":"","code":"# continue from code chunk above ## WARNING: Use many more num_PCs (20+) for \"real\" genomic data trained_model <- model_build(mm_pca$PCA$x,                              gsub('\\\\d+','', mm_pca$meta$samples), #remove trailing digit                               model = 'lm', num_PCs = 2)  label_guesses <- model_apply(trained_model,                              projected_pca,                              c(\"Cornea\",\"Cornea\",\"Cornea\") )  # label_guesses"},{"path":"https://davemcg.github.io/metamoRph/index.html","id":"existing-prcomp-object-projection-example-pseudocode-ish","dir":"","previous_headings":"","what":"Existing prcomp object projection example (pseudocode-ish)","title":"Metadata projection via data morphing with matrix factorization multiplication","text":"also possible use pre-existing prcomp object metamoRph, skipping run_pca step. ensure sample scale new_data manner used prcomp run (use log2 - replace whatever scaling done. Maybe none?). Note turned cpm log1p scaling metamoRph function.","code":"library(metamoRph) projected_pca <- metamoRph(t(log2(new_data)),                                 your_prcomp_object$PCA$rotation,                                 center_scale = extract_prcomp_scaling(your_prcomp_object),                                sample_cpm_scale = FALSE, log1p = FALSE)"},{"path":"https://davemcg.github.io/metamoRph/reference/extract_prcomp_scaling.html","id":null,"dir":"Reference","previous_headings":"","what":"extract_prcomp_scaling — extract_prcomp_scaling","title":"extract_prcomp_scaling — extract_prcomp_scaling","text":"function takes prcomp object returns center scale vectors list direct use metamoRph::metamoRph.","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/extract_prcomp_scaling.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"extract_prcomp_scaling — extract_prcomp_scaling","text":"","code":"extract_prcomp_scaling(prcomp_object)"},{"path":"https://davemcg.github.io/metamoRph/reference/extract_prcomp_scaling.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"extract_prcomp_scaling — extract_prcomp_scaling","text":"prcomp_object precomputed prcomp object","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/extract_prcomp_scaling.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"extract_prcomp_scaling — extract_prcomp_scaling","text":"list object containing prcomp \"center\" \"scale\" values use metamoRph function","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/metamoRph.html","id":null,"dir":"Reference","previous_headings":"","what":"metamoRph — metamoRph","title":"metamoRph — metamoRph","text":"function takes count matrix (genes (features) rows samples columns) well named vector eigenvalues (see run_pca()) pulls gene (feature) information rotation vector cuts new_counts matrix match rotation vector gene (feature) names. genes (features) missing input new_counts matrix replaced zeros.","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/metamoRph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"metamoRph — metamoRph","text":"","code":"metamoRph(   new_counts,   rotation,   center_scale = NULL,   sample_cpm_scale = TRUE,   log1p = TRUE )"},{"path":"https://davemcg.github.io/metamoRph/reference/metamoRph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"metamoRph — metamoRph","text":"new_counts raw gene count matrix (genes rows samples columns) rotation matrix row names genes col names principal components. used metamoRph::run_pca() output$PCA$rotation slot. center_scale list object $center slot center values $scale slot scale value \"scale\" function. give value , feature/gene scaling HAPPEN. sample_cpm_scale Default TRUE; match value given metamoRph::run_pca(). using rotations know whether done cpm scaling ...probably set FALSE. log1p Default TRUE; log1p scales input count matrix","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/metamoRph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"metamoRph — metamoRph","text":"matrix transformated eigenvalue matrix equivalent original rotation matrix's eigenvalue/pattern matrix ($x slot output prcomp)","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/metamoRph.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"metamoRph — metamoRph","text":"function scale new_counts matrix manner run_pca() matrix multiply rotation vector. output equivalent prcomp \"$x\" matrix.","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/model_apply.html","id":null,"dir":"Reference","previous_headings":"","what":"model_apply — model_apply","title":"model_apply — model_apply","text":"function uses output model_build()","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/model_apply.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"model_apply — model_apply","text":"","code":"model_apply(   list_of_models,   experiment_data,   experiment_labels = \"\",   return_predictions = FALSE )"},{"path":"https://davemcg.github.io/metamoRph/reference/model_apply.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"model_apply — model_apply","text":"list_of_models list object containing one model per sample type (e.g. photoreceptors vs -photoreceptors) experiment_data Projected data metamoRph() experiment_labels Optional labels users experiment_data return_predictions default predicted labels returned. set TRUE, entire matrix probabilities sample (label type) returned.","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/model_apply.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"model_apply — model_apply","text":"default, table predicted labels data, return_predictions set TRUE matrix probabilities sample type returned (rows samples columns sample type probability)","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/model_build.html","id":null,"dir":"Reference","previous_headings":"","what":"model_build — model_build","title":"model_build — model_build","text":"function uses training_data training_labels build lm based model label type can used model_apply(). training_data intended sample x PC (principal component) row x column matrix. $x output base R prcomp. provide precomputed prcomp PCA outputs plae.nei.nih.gov resource adult human eye, adult mouse eye, fetal human eye, fetal mouse eye ( see vignette(\"pca_download\", package = \"metamoRph\"))","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/model_build.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"model_build — model_build","text":"","code":"model_build(   training_data,   training_labels,   num_PCs = 200,   BPPARAM = BiocParallel::SerialParam(),   model = \"lm\",   verbose = TRUE )"},{"path":"https://davemcg.github.io/metamoRph/reference/model_build.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"model_build — model_build","text":"training_data sample (row) principal component (column) matrix training_labels vector row-matched labels (e.g. cell types) sample. num_PCs number principal components use training_data. Defaults first (top) 200. BPPARAM BiocParallel class model Default lm. also support xgboost, glm, rf, svm. experience find lm svm best performers. verbose Print training status label type","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/model_build.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"model_build — model_build","text":"list models individual label type","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/run_pca.html","id":null,"dir":"Reference","previous_headings":"","what":"run_pca — run_pca","title":"run_pca — run_pca","text":"function takes count matrix (genes (features) rows samples columns) sample level metadata returns list object R::prcomp calculated object, metadata, percent variance explained principal component, genes (features) chosen PCA","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/run_pca.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"run_pca — run_pca","text":"","code":"run_pca(   feature_by_sample,   meta,   ntop = 1000,   hvg_selection = \"scran\",   hvg_force = NULL,   feature_scale = TRUE,   feature_center = TRUE,   sample_cpm_scale = TRUE,   log1p = TRUE,   remove_regex = \"^MT|^RPS|^RPL\" )"},{"path":"https://davemcg.github.io/metamoRph/reference/run_pca.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"run_pca — run_pca","text":"feature_by_sample Raw feature (gene) count matrix (genes/features rows samples columns). meta Metadata samples. rows must match columns feature_by_sample. ntop Number highly variable genes/features use prcomp PCA. Defaults 1000. hvg_selection Either \"classic\" \"scran\" select \"ntop\" features. \"classic\" simply use top n features variance, \"scran\" use scran package's strategy scaling variance expression (highly expressed features/genes) also higher variance thus may less useful sample distinction. hvg_force Optional vector features / genes must stats::promp input feature_scale Default TRUE, means features (genes) scaled R::scale function. feature_center Default TRUE, means features (genes) centered sample_cpm_scale Default TRUE; performs cpm scaling samples edgeR::cpm function. log1p Default TRUE; applies log1p scaling input count matrix. remove_regex Default regex pattern '^MT|^RPS|^RPL'. Set '' skip.","code":""},{"path":"https://davemcg.github.io/metamoRph/reference/run_pca.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"run_pca — run_pca","text":"named list object prcomp output returned $PCA slot, given metadata $meta slot, percent variance PC $percentVar slot, list object containing scaled data's \"center\" \"scale\" values use metamoRph function, used parameters $params slot.","code":""},{"path":"https://davemcg.github.io/metamoRph/news/index.html","id":"metamorph-012","dir":"Changelog","previous_headings":"","what":"metamoRph 0.1.2","title":"metamoRph 0.1.2","text":"add tests testthat tweak Metadata Label Transfer Real Data vignette plots mark tissue grouping ggforce::geom_mark_ellipse","code":""},{"path":"https://davemcg.github.io/metamoRph/news/index.html","id":"metamorph-011","dir":"Changelog","previous_headings":"","what":"metamoRph 0.1.1","title":"metamoRph 0.1.1","text":"improve vignettes add extract_prcomp_scaling()function yank center/scale information prcomp object","code":""},{"path":"https://davemcg.github.io/metamoRph/news/index.html","id":"metamorph-010","dir":"Changelog","previous_headings":"","what":"metamoRph 0.1.0","title":"metamoRph 0.1.0","text":"release","code":""}]
